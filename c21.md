# ГЛАВА 21. Пространство имен System
В этой главе речь пойдет о пространстве имен System.
Это пространство имен самого верхнего уровня в би­
блиотеке классов для среды .NET Framework. В нем
непосредственно находятся те классы, структуры, интер­
фейсы, делегаты и перечисления, которые чаще всего при­
меняются в программах на C# или же считаются неотъем­
лемой частью среды .NET Framework. Таким образом, про­
странство имен System составляет ядро рассматриваемой
здесь библиотеки классов.

Кроме того, в пространство имен System входит много
вложенных пространств имен, поддерживающих отдель­
ные подсистемы, например System.Net. Некоторые из
этих пространств имен рассматриваются далее в этой кни­
ге. А в этой главе речь пойдет только о членах самого про­
странства имен System.

## Члены пространства имен System
Помимо большого количества классов исключений, в пространстве имен содержат­
ся приведенные ниже классы.
В пространстве имен System определены приведенные ниже интерфейсы.
ActivationContext Activator AppDomain
AppDomainManager AppDomainSetup Applicationld
Applicationldentity Array AssemblyLoadEventArgs
Attribute AttributeUsageAttribute BitConverter
Buffer CharEnumerator CLSCompliantAttribute
Console ConsoleCancelEventArgs ContextBoundObject
ContextStaticAttribute Convert DBNull
Delegate Enum Environment
EventArgs Exception FileStyleUriParser
FlagsAttribute FtpStyleUriParser GC
GenericUriParser GopherStyleUriParser HttpStyleUriParser
Lazy<T> Lazy<T, TMetadata> LdapStyleUriParser
LoaderOptimizationAttribute LocalDataStoreSlot MarshalByRefObject
Math MTAThreadAttribute MulticastDelegate
NetPipeStyleUriParser NetTcpStyleUriParser NewsStyleUriParser
NonSerializedAttribute Nullable Object
ObsoleteAttribute OperatingSystem ParamArrayAttribute
Random ResolveEventArgs SerializableAttribute
STAThreadAttribute String StringComparer
Th rea dStaticAttri bute TimeZone TimeZonelnfo
TimeZonelnfo.AdjustmentRule Tuple Tuple<...> (различные формы)
Type Unhandled ExceptionEventArgs Uri
UriBuilder Uri Parser UriTemplate
UriTemplateEquivalenceComparer UriTemplateMatch UriTemplateTable
UriTypeConverter ValueType Version
WeakReference
Ниже приведены структуры, определенные в пространстве имен System.
Arglterator ArraySegment<T> Boolean
Byte Char ConsoleKeylnfo
DateTime DateTimeOffset Decimal
Double Guid Int16
Int32 Int64 IntPtr
ModuleFlandle Nullable<T> RuntimeArgumentFlandle
RuntimeFieldFlandle RuntimeMethodHandle RuntimeTypeHandle
Sbyte Single TimeSpan
TimeZonelnfo.TransitionTime TypedReference Ulnt16
Ulnt32 Ulnt64 UIntPtr
Void
Как следует из приведенных выше таблиц, пространство имен System доволь­
но обширно, поэтому в одной главе невозможно рассмотреть подробно все его со­
ставляющие. К тому же, некоторые члены пространства имен System, в том числе
Nullable<T>, Type, Exception и Attribute, уже рассматривались в части I или будут
представлены в последующих главах части II. И наконец, класс System.String, в ко­
тором определяется тип string для символьных строк в С#, обсуждается вместе с во­
просами форматирования в главе 22. В силу этих причин в настоящей главе рассматри­
ваются только те члены данного пространства имен, которые чаще всего применяются
в программировании на C# и не поясняются полностью в остальных главах книги.
Класс Math
В классе Math определен ряд стандартных математических операций, в том чис­
ле извлечение квадратного корня, вычисление синуса, косинуса и логарифмов. Класс
Math является статическим, а это означает, что все методы, определенные в нем, отно­
сятся к типу static, объекты типа Math не конструируются, а сам класс Math неявно
герметичен и не может наследоваться. Методы, определенные в классе Math, перечис­
лены в табл. 21.1, где все углы указаны в радианах.
В классе Math определены также два следующих поля:
public const double Е
public const double PI
где E — значение основания натурального логарифма числа, которое обычно обозна­
чается как е; a PI — значение числа пи.
_AppDomain lappDomainSetup lAsyncResult
lCloneable IComparable IComparable<T>
IConvertible ICustomFormatter IDisposable
IEquatable<T> IFormatProvider IFormattable
IObservable<T> IObserver<T> IServiceProvider
Ниже приведены делегаты, определенные в пространстве имен System.
Action Action<...> (различные формы) AppDomainlnitializer
AssemblyLoadEventHandler AsyncCallback Comparison<T>
ConsoleCancelEventHandler Converter<Tlnput, VOutput> CrossAppDomainDelegate
EventHandler EventHandler<TEventArgs> Func<...> (различные формы)
Predicate<T> ResolveEventHandler UnhandledExceptionEventHandler
В пространстве имен System определены приведенные ниже перечисления.
ActivationContext.contextForm AppDomainManagerlnitializationOptions AttributeTargets
Base64Formatting0ptions ConsoleColor ConsoleKey
ConsoleModifiers ConsoleSpecialKey DateTimeKind
DayOfWeek Environment.SpecialFolder Environment.SpecialFolderOption
EnvironmentVariableTarget GCCollectionMode GCNotificationStatus
GenericUriParserOptions LoaderOptimization MidpointRounding
PlatformID StringComparison StringSplitOptions
TypeCode UriComponents UriFormat
UriHostNameType UrildnScope UriKind
UriPartial
Таблица 21.1. Методы, определенные в классе Math
Метод Описание
public static double
Abs(double value)
Возвращает абсолютную величину value
public static float
Abs(float value)
Возвращает абсолютную величину value
public static decimal
Abs(decimal value)
Возвращает абсолютную величину value
public static int Abs(int
value)
Возвращает абсолютную величину value
public static short
Abs(short value)
Возвращает абсолютную величину value
public static long Abs(long
value)
Возвращает абсолютную величину value
public static sbyte
Abs(sbyte value)
Возвращает абсолютную величину value
public static double
Acos(double d)
Возвращает арккосинус d. Значение d должно на­
ходиться в пределах от -1 до 1
public static double
Asin(double d)
Возвращает арксинус d. Значение d должно нахо­
диться в пределах от -1 до 1
public static double
Atan(double d)
Возвращает арктангенс d
public static double
Atan2(double y, double x)
Возвращает арктангенс частного от деления у/ х
public static long
BigMulfint a, int b)
Возвращает произведение а*b в виде значения
типа long, исключая переполнение
public static double
Ceiling(double a)
Возвращает наименьшее целое, которое пред­
ставлено в виде значения с плавающей точкой
и не меньше а. Так, если а равно 1,02, метод
Ceiling() возвращает значение 2,0. А если а
равно -1,02, то метод Ceiling() возвращает
значение -1
public static double
Ceiling(decimal d)
Возвращает наименьшее целое, которое представ­
лено в виде значения десятичного типа и не мень­
ше d. Так, если d равно 1,02, метод Ceiling()
возвращает значение 2,0. А если d равно -1,02, то
метод Ceiling() возвращает значение -1
public static double
Cos (double d)
Возвращает косинус d
public static double
Cosh(double d)
Возвращает гиперболический косинус d
public static int DivRem(int a,
int b, out int result)
public static
long DivRem(long a,
long b, out long result)
Возвращает частное от деления а/b, а остаток —
в виде параметра result типа out
Возвращает частное от деления а/b, а остаток —
в виде параметра result типа out
Продолжение табл. 21.1
Метод Описание
public static double
Exp (double d)
Возвращает основание натурального логарифма е,
возведенное в степень d
public static decimal
Floor(decimal d)
Возвращает наибольшее целое, которое представ­
лено в виде значения десятичного типа и не больше
d. Так, если d равно 1,02, метод Floor() возвра­
щает значение 1,0. А если d равно -1,02, метод
Floor() возвращает значение -2
public static double
Floor(double d)
Возвращает наибольшее целое, которое представ­
лено в виде значения с плавающей точкой и не
больше d. Так, если d равно 1,02, метод Floor()
возвращает значение 1,0. А если d равно -1,02,
метод Floor() возвращает значение -2
public static double
IEEERemainder(double x,
double y)
Возвращает остаток от деления х/ у
public static double
Log(double d)
Возвращает натуральный логарифм значения d
public static double
Log(double d, double
newBase)
Возвращает натуральный логарифм по основанию
newBase значения d
public static double
Log10(double d)
Возвращает логарифм по основанию 10 значения d
public static double
Max(double val1, double val2)
Возвращает большее из значений val1 и val2
public static float
Max(float val1, float val2)
Возвращает большее из значений val1 и val2
public static decimal
Max(decimal val1, decimal
val2)
Возвращает большее из значений val1 и val2
public static int Max(int
val1, int val2)
Возвращает большее из значений val1 и val2
public static short Max(short
val1, short val2)
Возвращает большее из значений val1 и val2
public static long Max (long
val1, long val2)
Возвращает большее из значений val1 и val2
public static uint Max (uint
val1, uint val2)
Возвращает большее из значений val1 и val2
public static ushort
Max(ushort val1, ushort val2)
Возвращает большее из значений val1 и val2
public static ulong
Max(ulong val1, ulong val2)
Возвращает большее из значений val1 и val2
public static byte Max(byte
val1, byte val2)
Возвращает большее из значений val1 и val2
public static sbyte Max(sbyte
val1, sbyte val2)
Возвращает большее из значений val1 и val2
Продолжение табл. 21.1
Метод Описание
public static double
Min(double val1, double val2)
Возвращает меньшее из значений val1 и val2
public static float
Min(float val1, float val2)
Возвращает меньшее из значений val1 и val2
public static decimal
Min(decimal val1, decimal
val2)
Возвращает меньшее из значений val1 и val2
public static int Min(int
val1, int val2)
Возвращает меньшее из значений val1 и val2
public static short Min(short
val1, short val2)
Возвращает меньшее из значений val1 и val2
public static long Min(long
val1, long val2)
Возвращает меньшее из значений val1 и val2
public static uint Min(uint
val1, uint val2)
Возвращает меньшее из значений val1 и val2
public static ushort
Min(ushort val1, ushort val2)
Возвращает меньшее из значений val1 и val2
public static ulong Min(ulong
val1, ulong val2)
Возвращает меньшее из значений val1 и val2
public static byte Min(byte
val1, byte val2)
Возвращает меньшее из значений val1 и val2
public static sbyte Min(sbyte
val1, sbyte val2)
Возвращает меньшее из значений val1 и val2
public static double
Pow(double x, double y)
Возвращает значение х, возведенное в степень
у(xy)
public static double
Round(double a)
Возвращает значение а, округленное до ближайше­
го целого числа
public static decimal
Round(decimal d)
Возвращает значение d, округленное до ближайше­
го целого числа
public static double
Round(double value,
int digits)
Возвращает значение value, округленное до чис­
ла, количество цифр в дробной части которого рав­
но значению параметра digits
public static decimal
Round(decimal d, int digits)
Возвращает значение d, округленное до числа, ко­
личество цифр в дробной части которого равно зна­
чению digits
public static double
Round(double value,
MidpointRounding mode)
Возвращает значение value, округленное до бли­
жайшего целого числа в режиме, определяемом
параметром mode
public static decimal
Round(decimal d,
MidpointRounding mode)
Возвращает значение d, округленное до ближайше­
го целого числа в режиме, определяемом параме­
тром mode
public static double
Round(double value, int
digits, MidpointRounding
mode)
Возвращает значение value, округленное до чис­
ла, количество цифр в дробной части которого рав­
но значению digits, а параметр mode определяет
режим округления
Окончание табл. 21.1
В приведенном ниже примере программы метод Sqrt() служит для расчета ги­
потенузы по длине противоположных сторон прямоугольного треугольника согласно
теореме Пифагора.
Метод Описание
public static decimal
Round(decimal d, int digits,
MidpointRounding mode)
Возвращает значение d, округленное до числа,
количество цифр в дробной части которого равно
значению digits, а параметр mode определяет
режим округления
public static int
Sign(double value)
Возвращает -1, если значение value меньше нуля;
0, если значение value равно нулю; и 1, если зна­
чение value больше нуля
public static int Sign (float
value)
Возвращает -1, если значение value меньше нуля;
0, если значение value равно нулю; и 1, если зна­
чение value больше нуля
public static int
Sign(decimal value)
Возвращает -1, если значение value меньше нуля;
0, если значение value равно нулю; и 1, если зна­
чение value больше нуля
public static int Sign(int
value)
Возвращает -1, если значение value меньше нуля;
0, если значение value равно нулю; и 1, если зна­
чение value больше нуля
public static int Sign(short
value)
Возвращает -1, если значение value меньше нуля;
0, если значение value равно нулю; и 1, если зна­
чение value больше нуля
public static int Sign (long
value)
Возвращает -1, если значение value меньше нуля;
0, если значение value равно нулю; и 1, если зна­
чение value больше нуля
public static int Sign(sbyte
value)
Возвращает -1, если значение value меньше нуля;
0, если значение value равно нулю; и 1, если зна­
чение value больше нуля
public static double
Sin(double a)
Возвращает синус числа а
public static double
Sinh(double value)
Возвращает гиперболический синус числа value
public static double
Sqrt(double d)
Возвращает квадратный корень числа d
public static double
Tan(double a)
Возвращает тангенс числа а
public static double
Tanh(double value)
Возвращает гиперболический тангенс числа
value
public static double
Truncate(double d)
Возвращает целую часть числа d
public static decimal
Truncate(decimal d)
Возвращает целую часть числа d
// Расчет гипотенузы по теореме Пифагора.
using System;
class Pythagorean {
static void Main() {
double s1;
double s2;
double hypot;
string str;
Console.WriteLine("Введите длину первой стороны треугольника: ");
str = Console.ReadLine();
s1 = Double.Parse(str);
Console.WriteLine("Введите длину второй стороны треугольника: ");
str = Console.ReadLine();
s2 = Double.Parse(str);
hypot = Math.Sqrt(s1*s1 + s2*s2);
Console.WriteLine("Длина гипотенузы равна " + hypot);
}
}
Ниже приведен один из возможных результатов выполнения этой программы.
Введите длину первой стороны треугольника: 3
Введите длину второй стороны треугольника: 4
Длина гипотенузы равна: 5
Далее следует пример программы, в которой метод Pow() служит для расчета пер­
воначальных капиталовложений, требующихся для получения предполагаемой буду­
щей стоимости, исходя из годовой нормы прибыли и количества лет. Ниже приведена
формула для расчета первоначальных капиталовложений.
первоначальные капиталовложения =
будущая стоимость / (1 + норма прибыли)количество лет
В вызове метода Pow() необходимо указывать аргументы типа double, поэтому
норма прибыли и количество лет задаются в виде значений типа double. А перво­
начальные капиталовложения и будущая стоимость задаются в виде значений типа
decimal.
/* Рассчитать первоначальные капиталовложения, необходимые
для получения заданной будущей стоимости, исходя из
годовой нормы прибыли и количества лет. */
using System;
class InitialInvestment {
static void Main() {
decimal initInvest; // первоначальные капиталовложения
decimal futVal; // будущая стоимость
double numYears; // количество лет
double intRate; // годовая норма прибыли
string str;
Console.Write("Введите будущую стоимость: ");
str = Console.ReadLine();
try {
futVal = Decimal.Parse(str);
} catch(FormatException exc) {
Console.WriteLine(exc.Message);
return;
}
Console.Write("Введите норму прибыли (например, 0.085): ");
str = Console.ReadLine();
try {
intRate = Double.Parse(str);
} catch(FormatException exc) {
Console.WriteLine(exc.Message);
return;
}
Console.Write("Введите количество лет: ");
str = Console.ReadLine();
try {
numYears = Double.Parse(str);
} catch(FormatException exc) {
Console.WriteLine(exc.Message);
return;
}
initInvest =
futVal / (decimal) Math.Pow(intRate+1.0, numYears);
Console.WriteLine("Необходимые первоначальные капиталовложения: {0:C}",
initInvest);
}
}
Ниже приведен один из возможных результатов выполнения этой программы.
Введите будущую стоимость: 10000
Введите норму прибыли (например, 0.085): 0.07
Введите количество лет: 10
Необходимые первоначальные капиталовложения: $5,083.49
Структуры .NET, соответствующие встроенным типам значений
Структуры, соответствующие встроенным в C# типам значений, были представлены
в главе 14, где они упоминались в связи с преобразованием строк, содержащих число­
вые значения в удобочитаемой форме, в эквивалентные двоичные значения. В этом
разделе структуры .NET рассматриваются более подобно.
Имена структур .NET и соответствующие им ключевые слова, обозначающие типы
значений в С#, перечислены в приведенной ниже таблице.
Имя структуры в .NET Имя типа значения в C#
System.Boolean bool
System.Char char
System.Decimal decimal
System.Double double
System.Single float
System.Int16 short
System.Int32 int
System.Int64 long
System.UInt16 ushort
System.UInt32 uint
System.UInt64 ulong
System.Byte byte
System.Sbyte sbyte
Используя члены, определенные в этих структурах, можно выполнять операции
над значениями простых типов данных. Все перечисленные выше структуры рассма­
триваются далее по порядку.
ПРИМЕЧАНИЕ
Некоторые методы, определенные в структурах, соответствующих встроенным в C# ти­
пам значений, принимают параметры типа IFormatProvider или NumberStyles. Тип
IFormatProvider вкратце описывается далее в этой главе, а тип NumberStyles пред­
ставляет собой перечисление из пространства имен System.Globalization. Вопросы
форматирования подробнее рассматриваются в главе 22.
Структуры целочисленных типов данных
Ниже перечислены структуры целочисленных типов данных.
Byte SByte Int16 Uint16
Int32 UInt32 Int64 UInt64
Каждая из этих структур содержит одинаковое количество членов. В табл. 21.2 для
примера перечислены члены структуры Int32. Аналогичные члены в виде методов
имеются и у других структур, за исключением целочисленного типа, который они
представляют.
Помимо перечисленных выше методов, в структурах целочисленных типов данных
определены следующие поля типа const.
MaxValue
MinValue
В каждой структуре эти поля содержат наибольшее и наименьшее значения, до­
пустимые для данных соответствующего целочисленного типа.
Во всех структурах целочисленных типов данных реализуются следующие ин­
терфейсы: IComparable, IComparable<T>, IConvertible, IFormattable
и IEquatable<T>, где параметр обобщенного типа Т заменяется соответствующим
типом данных. Например, в структуре Int32 вместо Т подставляется тип int.
Таблица 21.2. Методы, поддерживаемые структурой Int32
Метод Назначение
public int
CompareTo(object value)
Сравнивает числовое значение вызывающего объекта со
значением value. Возвращает нуль, если сравниваемые
значения равны; отрицательное значение, если вызыва­
ющий объект имеет меньшее значение; и, наконец, по­
ложительное значение, если вызывающий объект имеет
большее значение
public int CompareTo(int
value)
Сравнивает числовое значение вызывающего объекта со
значением value. Возвращает нуль, если сравниваемые
значения равны; отрицательное значение, если вызыва­
ющий объект имеет меньшее значение; и, наконец, по­
ложительное значение, если вызывающий объект имеет
большее значение
public override bool
Equals(object obj)
Возвращает логическое значение true, если значе­
ние вызывающего объекта равно значению параметра
obj
public bool Equals(int
obj)
Возвращает логическое значение true, если значе­
ние вызывающего объекта равно значению параметра
obj
public override int
GetHashCode()
Возвращает хеш-код для вызывающего объекта
public TypeCode
GetTypeCode()
Возвращает значение перечисления TypeCode для экви­
валентного типа. Например, для структуры Int32 возвра­
щается значение TypeCode.Int32
public static int
Parse(string s)
Возвращает двоичный эквивалент числа, заданного
в виде символьной строки s. Если числовое значение не
представлено в строке так, как определено в структуре
данного типа, то генерируется исключение
public static int
Parse(string s,
IformatProvider
provider)
Возвращает двоичный эквивалент числа, заданного
в виде символьной строки s, с использованием фор­
матов данных, характерных для конкретной культурной
среды и определяемых параметром provider. Если
числовое значение не представлено в строке так, как
определено в структуре данного типа, то генерируется
исключение
public static int
Parse(string s,
NumberStyles styles)
Возвращает двоичный эквивалент числа, заданного
в виде символьной строки s, с использованием дан­
ных о стилях, определяемых параметром styles. Если
числовое значение не представлено в строке так, как
определено в структуре данного типа, то генерируется
исключение
Окончание табл. 21.2
Структуры типов данных с плавающей точкой
Типам данных с плавающей точкой соответствуют только две структуры: Double
и Single. Структура Single представляет тип float. Ее методы перечисле­
ны в табл. 21.3, а поля — в табл. 21.4. Структура Double представляет тип double.
Метод Назначение
public static int
Parse (string s,
NumberStyles styles,
IformatProvider
provider)
Возвращает двоичный эквивалент числа, заданного в виде
строки символьной s, с использованием данных о стилях,
определяемых параметром styles, а также форматов
данных, характерных для конкретной культурной среды
и определяемых параметром provider. Если числовое
значение не представлено в строке так, как определено
в структуре данного типа, то генерируется исключение
public override string
ToString()
Возвращает строковое представление значения вызы­
вающего объекта
public string
ToString(string format)
Возвращает строковое представление значения вызы­
вающего объекта, как указано в форматирующей строке,
определяемой параметром format
public string
ToString(IformatProvider
provider)
Возвращает строковое представление значения вызы­
вающего объекта с использованием форматов данных,
характерных для конкретной культурной среды и опреде­
ляемых параметром provider
public string
ToString(string format,
IformatProvider
provider)
Возвращает строковое представление значения вызы­
вающего объекта, как указано в форматирующей строке,
определяемой параметром format, но с использова­
нием форматов данных, характерных для конкретной куль­
турной среды и определяемых параметром provider
public static bool
TryParse(string s, out
int result)
Предпринимает попытку преобразовать числовое значе­
ние, заданное в виде символьной строки s, в двоичное
значение. При успешной попытке это значение сохраняет­
ся в параметре result и возвращается логическое зна­
чение true, а иначе возвращается логическое значение
false, в отличие от метода Parse(), который генери­
рует исключение при неудачном исходе преобразования
public static bool
TryParse(string s,
NumberStyles styles,
IformatProvider
provider, out int
result)
Предпринимает попытку преобразовать числовое зна­
чение, заданное в виде символьной строки s, в двоич­
ное значение с использованием информации о стилях,
обозначаемых параметром styles, а также форматов
данных, характерных для конкретной культурной среды
и определяемых параметром provider. При успешной
попытке это значение сохраняется в параметре result
и возвращается логическое значение true, а иначе воз­
вращается логическое значение false, в отличие от
метода Parse(), который генерирует исключение при
неудачном исходе преобразования
Ее методы перечислены в табл. 21.5, а поля — в табл. 21.6. Как и в структурах цело­
численных типов данных, при вызове метода Parse() или ToString() из структур
типов данных с плавающей точкой можно указывать информацию, характерную для
конкретной культурной среды, а также данные форматирования.
Таблица 21.3. Методы, поддерживаемые структурой Single
Метод Назначение
public int
CompareTo(object value)
Сравнивает числовое значение вызывающего объекта
со значением value. Возвращает нуль, если сравнивае­
мые значения равны; отрицательное число, если вызы­
вающий объект имеет меньшее значение, и, наконец,
положительное значение, если вызывающий объект
имеет большее значение
public int
CompareTo(float value)
Сравнивает числовое значение вызывающего объекта
со значением value. Возвращает нуль, если сравнивае­
мые значения равны; отрицательное число, если вызы­
вающий объект имеет меньшее значение, и, наконец,
положительное значение, если вызывающий объект
имеет большее значение
public override bool
Equals(object obj)
Возвращает логическое значение true, если значение
вызывающего объекта равно значению obj
public bool Equals(float
obj)
Возвращает логическое значение true, если значение
вызывающего объекта равно значению obj
public override int
GetHashCode()
Возвращает хеш-код для вызывающего объекта
public TypeCode
GetTypeCode()
Возвращает значение из перечисления TypeCode для
структуры Single, т.е. TypeCode.Single
public static bool
IsInfinity(float f)
Возвращает логическое значение true, если значение
f представляет плюс или минус бесконечность. В против­
ном случае возвращает логическое значение false
public static bool
IsNaN(float f)
Возвращает логическое значение true, если значение f
не является числовым. В противном случае возвращает
логическое значение false
public static bool
IsPositiveInfinity(float
f)
Возвращает логическое значение true, если значение
f представляет плюс бесконечность. В противном случае
возвращает логическое значение false
public static bool
IsNegativeInfinity(float
f)
Возвращает логическое значение true, если значение f
представляет минус бесконечность. В противном случае
возвращает логическое значение false
public static float
Parse(string s)
Возвращает двоичный эквивалент числа, заданного в виде
символьной строки s. Если в строке не представлено чис­
ловое значение типа float, то генерируется исключение
public static float
Parse(string s,
IformatProvider
provider)
Возвращает двоичный эквивалент числа, заданного
в виде символьной строки s, с использованием фор­
матов данных, характерных для конкретной культурной
среды и определяемых параметром provider. Если в
строке не представлено числовое значение типа float,
то генерируется исключение
Окончание табл. 21.3
Метод Назначение
public static float
Parse(string s,
NumberStyles styles)
Возвращает двоичный эквивалент числа, заданного в
виде символьной строки s, с использованием данных о
стилях, определяемых параметром styles. Если в стро­
ке не представлено числовое значение типа float, то
генерируется исключение
public static float
Parse(string s,
NumberStyles styles,
IformatProvider
provider)
Возвращает двоичный эквивалент числа, заданного в
виде символьной строки s, с использованием форматов
данных, характерных для конкретной культурной среды
и определяемых параметром provider, а также сведе­
ний о стилях, обозначаемых параметром styles. Если в
строке не представлено числовое значение типа float,
то генерируется исключение
public override string
ToString()
Возвращает строковое представление значения вызы­
вающего объекта
public string
ToString(string format)
Возвращает строковое представление значения вызы­
вающего объекта, как указано в форматирующей строке,
 определяемой параметром format
public string
ToString(IformatProvider
provider)
Возвращает строковое представление значения вызы­
вающего объекта с использованием форматов данных,
характерных для конкретной культурной среды и опреде­
ляемых параметром provider
public string
ToString(string format,
IformatProvider
provider)
Возвращает строковое представление значения вызы­
вающего объекта, как указано в форматирующей строке,
определяемой параметром format, но с использовани­
ем форматов данных, характерных для конкретной куль­
турной среды и определяемых параметром provider
public static bool
TryParse(string s, out
float result)
Предпринимает попытку преобразовать число, заданное
в виде символьной строки s, в значение типа float.
При успешной попытке это значение сохраняется в па­
раметре result и возвращается логическое значе­
ние true, а иначе возвращается логическое значение
false, в отличие от метода Parse(), который генериру­
ет исключение при неудачном исходе преобразования
public static bool
TryParse(string s,
NumberStyles styles,
IformatProvider
provider, out float
result)
Предпринимает попытку преобразовать числовое зна­
чение, заданное в виде символьной строки s, в значе­
ние типа float, как указано в форматирующей строке,
определяемой параметром format, но с использовани­
ем форматов данных, характерных для конкретной куль­
турной среды и определяемых параметром provider,
а, также сведений о стилях, обозначаемых параметром
styles. При успешной попытке это значение сохраняет­
ся в параметре result и возвращается логическое зна­
чение true, а иначе возвращается логическое значение
false, в отличие от метода Parse(), который генериру­
ет исключение при неудачном исходе преобразования
Таблица 21.4. Поля, поддерживаемые структурой Single
Поле Назначение
public const float Epsilon Наименьшее ненулевое положительное значение
public const float
MaxValue
Наибольшее значение, допустимое для данных типа
float
public const float
MinValue
Наименьшее значение, допустимое для данных типа
float
public const float NaN Значение, не являющееся числом
public const float
NegativeInfinity
Значение, представляющее минус бесконечность
public const float
PositiveInfinity
Значение, представляющее плюс бесконечность
Таблица 21.5. Методы, поддерживаемые структурой Double
Метод Назначение
public int CompareTo(object
value)
Сравнивает числовое значение вызывающего объек­
та со значением value. Возвращает нуль, если срав­
ниваемые значения равны; отрицательное число,
если вызывающий объект имеет меньшее значение,
и, наконец, положительное значение, если вызываю­
щий объект имеет большее значение
public int CompareTo(double
value)
Сравнивает числовое значение вызывающего объек­
та со значением value. Возвращает нуль, если срав­
ниваемые значения равны; отрицательное число,
если вызывающий объект имеет меньшее значение,
и, наконец, положительное значение, если вызываю­
щий объект имеет большее значение
public override bool
Equals(object obj)
Возвращает логическое значение true, если значе­
ние вызывающего объекта равно значению obj
public bool Equals(double
obj)
Возвращает логическое значение true, если значе­
ние вызывающего объекта равно значению obj
public override int
GetHashCode()
Возвращает хеш-код для вызывающего объекта
public TypeCode
GetTypeCode()
Возвращает значение из перечисления TypeCode
для структуры Double, т.е. TypeCode.Double
public static bool
IsInfinity(double d)
Возвращает логическое значение true, если значе­
ние d представляет плюс или минус бесконечность.
В противном случае возвращает логическое значе­
ние false
public static bool
IsNaN(double d)
Возвращает логическое значение true, если зна­
чение d не является числовым. В противном случае
возвращает логическое значение false
public static bool
IsPositiveInfinity(double
d)
Возвращает логическое значение true, если значе­
ние d представляет плюс бесконечность. В противном
случае возвращает логическое значение false
Продолжение табл. 21.5
Метод Назначение
public static bool
IsNegativeInfinity(double
d)
Возвращает логическое значение true, если значе­
ние d представляет минус бесконечность. В против­
ном случае возвращает логическое значение false
public static double
Parse(string s)
Возвращает двоичный эквивалент числа, заданного
в виде символьной строки s. Если в строке не пред­
ставлено числовое значение типа double, то генери­
руется исключение
public static double
Parse(string s,
IFormatProvider provider)
Возвращает двоичный эквивалент числа, заданного в
виде символьной строки s, с использованием форма­
тов данных, характерных для конкретной культурной
среды и определяемых параметром provider. Если
в строке не представлено числовое значение типа
double, то генерируется исключение
public static double
Parse(string s,
NumberStyles styles)
Возвращает двоичный эквивалент числа, заданного в
виде символьной строки s, с использованием данных
о стилях, определяемых параметром styles. Если
в строке не представлено числовое значение типа
double, то генерируется исключение
public static double
Parse(string s,
NumberStyles styles,
IFormatProvider provider)
Возвращает двоичный эквивалент числа, заданного
в виде символьной строки s, с использованием фор­
матов данных, характерных для конкретной культур­
ной среды и определяемых параметром provider,
а также данных о стилях, обозначаемых параметром
styles. Если в строке не представлено числовое
значение типа double, то генерируется исключение
public override string
ToString()
Возвращает строковое представление значения вы­
зывающего объекта
public string
ToString(string format)
Возвращает строковое представление значения вы­
зывающего объекта, как указано в форматирующей
строке, определяемой параметром format
public string
ToString(IformatProvider
provider)
Возвращает строковое представление значения вы­
зывающего объекта с использованием форматов
данных, характерных для конкретной культурной сре­
ды и определяемых параметром provider
public string
ToString(string format,
IformatProvider provider)
Возвращает строковое представление значения вызы­
вающего объекта, как указано в форматирующей строке,
определяемой параметром format, но с использовани­
ем форматов данных, характерных для конкретной куль­
турной среды и определяемых параметром provider
public static bool
TryParse(string s, out
double result)
Предпринимает попытку преобразовать число, заданное
в виде символьной строки s, в значение типа double.
При успешной попытке это значение сохраняется в па­
раметре result и возвращается логическое значе­
ние true, а иначе возвращается логическое значение
false, в отличие от метода Parse(), который генери­
рует исключение при неудачном исходе преобразования
Окончание табл. 21.5
Структура Decimal
Структура Decimal немного сложнее, чем ее аналоги для целочисленных типов
данных, а также типов данных с плавающей точкой. Она содержит немало конструк­
торов, полей, методов и операторов, способствующих использованию типа decimal
вместе с другими числовыми типами, поддерживаемыми в С#. Так, целый ряд мето­
дов из этой структуры обеспечивает преобразование типа decimal в другие числовые
типы.
В структуре Decimal определено восемь открытых конструкторов. Ниже приведе­
ны шесть наиболее часто используемых из них.
public Decimal(int значение)
public Decimal(uint значение)
public Decimal(long значение)
public Decimal(ulong значение)
public Decimal(float значение)
public Decimal(double значение)
Метод Назначение
public static bool
TryParse(string s,
NumberStyles styles,
IFormatProvider provider,
out double result)
Предпринимает попытку преобразовать числовое
значение, заданное в виде символьной строки s, в
значение типа double, как указано в форматирую­
щей строке, определяемой параметром format, но
с использованием форматов данных, характерных
для конкретной культурной среды и определяемых
параметром provider, а также сведений о стилях,
обозначаемых параметром styles. При успеш­
ной попытке это значение сохраняется в параметре
result и возвращается логическое значение true,
а иначе возвращается логическое значение false,
в отличие от метода Parse(), который генерирует
исключение при неудачном исходе преобразования
Таблица 21.6. Поля, поддерживаемые структурой Double
Поле Назначение
public const double Epsilon Наименьшее ненулевое положительное значение
public const double
MaxValue
Наибольшее значение, допустимое для данных типа
double
public const double
MinValue
Наименьшее значение, допустимое для данных типа
double
public const double NaN Значение, не являющееся числом
public const double
NegativeInfinity
Значение, представляющее минус бесконечность
public const double
PositiveInfinity
Значение, представляющее плюс бесконечность
Каждый из этих конструкторов создает объект типа Decimal из значения указан­
ного типа.
Кроме того, объект типа Decimal может быть создан из отдельно указываемых со­
ставляющих с помощью следующего конструктора.
public Decimal (int lo, int mid, int hi, bool IsNegative, byte scale)
Десятичное значение состоит из трех частей. Первую часть составляет 96-разрядное
целое значение, вторую — флаг знака, третью — масштабный коэффициент. В част­
ности, 96-разрядное целое значение передается конструктору тремя 32-разрядными
фрагментами с помощью параметров lo, mid и hi; знак флага — с помощью пара­
метра IsNegative, причем логическое значение false этого параметра обозначает
положительное число, тогда как логическое значение true обозначает отрицательное
число; а масштабный коэффициент — с помощью параметра scale, принимающего
значения от 0 до 28. Этот коэффициент обозначает степень числа 10 (т.е. 10scale), на ко­
торую делится число для получения его дробной части.
Вместо того чтобы передавать каждую составляющую объекта типа Decimal от­
дельно, все его составляющие можно указать в массиве, используя следующий кон­
структор.
public Decimal(int[] bits)
Три первых элемента типа int в массиве bits содержат 96-разрядное целое значе­
ние; 31-й разряд содержимого элемента bits[3] обозначает флаг знака (0 — положи­
тельное число, 1 — отрицательное число); а в разрядах 16-23 содержится масштабный
коэффициент.
В структуре Decimal реализуются следующие интерфейсы: IComparable,
IComparable<decimal>, IConvertible, IFormattable, IEquatable<decimal>,
а также IDeserializationCallback.
В приведенном ниже примере программы значение типа decimal формируется
вручную.
// Сформировать десятичное число вручную.
using System;
class CreateDec {
static void Main() {
decimal d = new decimal(12345, 0, 0, false, 2);
Console.WriteLine(d);
}
}
Эта программа дает следующий результат.
123.45
В данном примере значение 96-разрядного целого числа равно 12345. У него поло­
жительный знак и два десятичных разряда в дробной части.
Методы, определенные в структуре Decimal, приведены в табл. 21.7, а поля —
в табл. 21.8. Кроме того, в структуре Decimal определяется обширный ряд операторов
и преобразований, позволяющих использовать десятичные значения вместе со значе­
ниями других типов в выражениях. Правила, устанавливающие порядок присваивания
десятичных значений и их применения в выражениях, представлены в главе 3.
Таблица 21.7. Методы, определенные в структуре Decimal
Метод Назначение
public static decimal
Add(decimal d1, decimal d2)
Возвращает значение d1 + d2
public static decimal
Ceiling(d)
Возвращает наименьшее целое, которое представ­
лено в виде значения типа decimal и не мень­
ше d. Так, если d равно 1,02, метод Ceiling()
возвращает значение 2,0. А если d равно -1,02,
то метод Ceiling() возвращает значение -1
public static int
Compare(decimal d1, decimal d2)
Сравнивает числовое значение d1 со значением
d2. Возвращает нуль, если сравниваемые зна­
чения равны; отрицательное значение, если d1
меньше d2; и, наконец, положительное значение,
если d1 больше d2
public int CompareTo(object
value)
Сравнивает числовое значение вызывающего
объекта со значением value. Возвращает нуль,
если сравниваемые значения равны; отрицательное
значение, если вызывающий объект имеет мень­
шее значение; и, наконец, положительное значение,
если вызывающий объект имеет большее значение
public int CompareTo(decimal
value)
Сравнивает числовое значение вызывающего объ­
екта со значением value. Возвращает нуль, если
сравниваемые значения равны; отрицательное зна­
чение, если вызывающий объект имеет меньшее
значение; и, наконец, положительное значение,
если вызывающий объект имеет большее значение
public static decimal
Divide(decimal d1,
decimal d2)
Возвращает частное от деления d1 / d2
public bool Equals(decimal
value)
Возвращает логическое значение true, если
значение вызывающего объекта равно значе­
нию value
public override bool
Equals(object value)
Возвращает логическое значение true, если
значение вызывающего объекта равно значе­
нию value
public static bool
Equals(decimal d1, decimal d2)
Возвращает логическое значение true, если
если d1 равно d2
public static decimal
Floor (decimal d)
Возвращает наибольшее целое, которое пред­
ставлено в виде значения типа decimal и не
больше d Так, если d равно 1,02, метод Floor()
возвращает значение 1,0. А если d равно -1,02,
метод Floor() возвращает значение -2
public static decimal
FromOACurrency(long cy)
Преобразует значение су из формата денеж­
ной единицы, применяемого в компоненте OLE
Automation, в его десятичный эквивалент и воз­
вращает полученный результат
Продолжение табл. 21.7
Метод Назначение
public static int[]
GetBits(decimal d)
Возвращает двоичное представление значения
d в виде массива типа int. Организация этого
массива описана в тексте настоящего раздела
public override int
GetHashCode()
Возвращает хеш-код для вызывающего объекта
public TypeCode GetTypeCode() Возвращает значение из перечисления
TypeCode для структуры Decimal, т.е.
TypeCode.Decimal
public static decimal
Multiply(decimal d1, decimal d2)
Возвращает произведение d1 * d2
public static decimal
Negate(decimal d)
Возвращает значение -d
public static decimal
Parse(string s)
Возвращает двоичный эквивалент числа, за­
данного в виде символьной строки s. Если в
строке не представлено числовое значение типа
decimal, то генерируется исключение
public static decimal
Parse(string s,
IFormatProvider provider)
Возвращает двоичный эквивалент числа, за­
данного в виде символьной строки s, с исполь­
зованием форматов данных, характерных для
конкретной культурной среды и определяемых
параметром provider. Если в строке не пред­
ставлено числовое значение типа decimal, то
генерируется исключение
public static decimal
Parse (string s, NumberStyles
styles)
Возвращает двоичный эквивалент числа, за­
данного в виде символьной строки s, с исполь­
зованием данных о стилях, определяемых пара­
метром styles. Если в строке не представлено
числовое значение типа decimal, то генери­
руется исключение
public static decimal
Parse (string s, NumberStyles
styles, IformatProvider
provider)
Возвращает двоичный эквивалент числа, за­
данного в виде символьной строки s, с исполь­
зованием форматов данных, характерных для
конкретной культурной среды и определяемых
параметром provider, а также данных о сти­
лях, обозначаемых параметром styles. Если в
строке не представлено числовое значение типа
decimal, то генерируется исключение
public static decimal
Remainder(decimal d1, decimal d2)
Возвращает остаток от целочисленного деления
d1 / d2
public static decimal
Round(decimal d)
Возвращает значение d, округленное до ближай­
шего целого числа
public static decimal
Round(decimal d, int decimals)
Возвращает значение d, округленное до числа с
количеством цифр в дробной части, равным зна­
чению параметра decimals, которое должно
находиться в пределах от 0 до 28
Продолжение табл. 21.7
Метод Назначение
public static decimal
Round(decimal d,
MidPoihtRounding mode)
Возвращает значение d, округленное до бли­
жайшего целого числа в режиме, определяе­
мом параметром mode. Режим округления при­
меняется лишь в том случае, если значение d
оказывается посредине между двумя целыми
числами
public static decimal
Round(decimal d, int decimals,
MidPointRounding mode)
Возвращает значение d, округленное до числа с
количеством цифр в дробной части, равным зна­
чению параметра decimals, которое должно на­
ходиться в пределах от 0 до 28, а параметр mode
определяет режим округления. Режим округления
применяется лишь в том случае, если значение
d оказывается посредине между двумя округляе­
мыми числами
public static decimal
Subtract(decimal d1, decimal d2)
Возвращает разность d1 - d2
public static byte
ToByte(decimal value)
Возвращает эквивалент значения value типа
byte. Дробная часть отбрасывается. Если зна­
чение value оказывается вне диапазона пред­
ставления чисел для типа byte, то генерируется
исключение OverflowException
public static double
ToDouble(decimal d)
Возвращает эквивалент значения d типа double.
При этом возможна потеря точности, поскольку у
значения типа double меньше значащих цифр,
чем у значения типа decimal
public static short
ToInt16(decimal d)
Возвращает эквивалент значения d типа short.
Дробная часть отбрасывается. Если значение d
оказывается вне диапазона представления чи­
сел для типа short, то генерируется исключение
OverflowException
public static int
ToInt32(decimal d)
Возвращает эквивалент значения d типа int.
Дробная часть отбрасывается. Если значение d
оказывается вне диапазона представления чи­
сел для типа int, то генерируется исключение
OverflowException
public static long
ToInt64(decimal d)
Возвращает эквивалент значения d типа long.
Дробная часть отбрасывается. Если значение d
оказывается вне диапазона представления чи­
сел для типа long, то генерируется исключение
OverflowException
public static long
ToOACurrency(decimal value)
Преобразует значение value в его эквивалент
формата денежной единицы, применяемого в
компоненте OLE Automation, и возвращает полу­
ченный результат
Продолжение табл. 21.7
Метод Назначение
public static sbyte
ToSByte(decimal value)
Возвращает эквивалент значения value типа
sbyte. Дробная часть отбрасывается. Если зна­
чение value оказывается вне диапазона пред­
ставления чисел для типа sbyte, то генерируется
исключение OverflowException
public static float
ToSingle(decimal d)
Возвращает эквивалент значения d типа float.
Дробная часть отбрасывается. Если значение d
оказывается вне диапазона представления чи­
сел для типа float, то генерируется исключение
OverflowException
public override string
ToString()
Возвращает строковое представление значения
вызывающего объекта в используемом по умол­
чанию формате
public string ToString(string
format)
Возвращает строковое представление значения
вызывающего объекта, как указано в форма­
тирующей строке, определяемой параметром
format
public string
ToString(IFormatProvider
provider)
Возвращает строковое представление значе­
ния вызывающего объекта с использованием
форматов данных, характерных для конкретной
культурной среды и определяемых параметром
provider
public string ToString(string
format, IFormatProvider
provider)
Возвращает строковое представление значения
вызывающего объекта, как указано в форма­
тирующей строке, определяемой параметром
format, но с использованием форматов данных,
характерных для конкретной культурной среды и
определяемых параметром provider
public static ushort
ToUInt16(decimal value)
Возвращает эквивалент значения value типа
ushort. Дробная часть отбрасывается. Если зна­
чение value оказывается вне диапазона пред­
ставления чисел для типа ushort, то генерирует­
ся исключение OverflowException
public static uint
ToUInt32(decimal d)
Возвращает эквивалент значения d типа uint.
Дробная часть отбрасывается. Если значение d
оказывается вне диапазона представления чи­
сел для типа uint, то генерируется исключение
OverflowException
public static ulong
ToUInt64(decimal d)
Возвращает эквивалент значения d типа ulong.
Дробная часть отбрасывается. Если значение d
оказывается вне диапазона представления чи­
сел для типа ulong, то генерируется исключение
OverflowException
public static decimal
Truncate(decimal d)
Возвращает целую часть числа d. Дробная часть
отбрасывается
Таблица 21.8. Поля, поддерживаемые структурой Decimal
Структура Char
Структура Char соответствует типу char и применяется довольно часто, посколь­
ку предоставляет немало методов, позволяющих обрабатывать символы и распреде­
лять их по отдельным категориям. Например, символ строчной буквы можно преоб­
разовать в символ прописной буквы, вызвав метод ToUpper(), а с помощью метода
IsDigit() можно определить, обозначает ли символ цифру.
Окончание табл. 21.7
Метод Назначение
public static bool
TryParse(string s, out decimal
result)
Предпринимает попытку преобразовать число­
вое значение, заданное в виде символьной стро­
ки s, в значение типа decimal. При успешной
попытке это значение сохраняется в параметре
result и возвращается логическое значение
true. В противном случае возвращается ло­
гическое значение false, в отличие от метода
Parse(), который генерирует исключение при
неудачном исходе преобразования
public static bool
TryParse(string s,
NumberStyles styles,
IFormatProvider provider, out
decimal result)
Предпринимает попытку преобразовать числовое
значение, заданное в виде символьной строки
s, в значение типа decimal, как указано в фор­
матирующей строке, определяемой параметром
format, но с использованием форматов данных,
характерных для конкретной культурной среды и
определяемых параметром provider, а также
сведений о стилях, обозначаемых параметром
styles. При успешной попытке это значение со­
храняется в параметре result и возвращается
логическое значение true. В противном случае
возвращается логическое значение false, в от­
личие от метода Parse(), который генерирует ис­
ключение при неудачном исходе преобразования
Поле Назначение
public static readonly
decimal MaxValue
Наибольшее значение, допустимое для данных типа
decimal
public static readonly
decimal MinusOne
Представление числа -1 в виде значения типа decimal
public static readonly
decimal MinValue
Наименьшее значение, допустимое для данных типа
decimal
public static readonly
decimal One
Представление числа 1 в виде значения типа decimal
public static readonly
decimal Zero
Представление числа 0 в виде значения типа decimal
Методы, определенные в структуре Char, приведены в табл. 21.9. Следует, од­
нако, иметь в виду, что некоторые методы, например ConvertFromUtf32()
и ConvertToUtf32(), позволяют обрабатывать символы уникода в форматах UTF-16
и UTF-32. Раньше все символы уникода могли быть представлены 16 разрядами, что
соответствует величине значения типа char. Но несколько лет назад набор символов
уникода был расширен, для чего потребовалось более 16 разрядов. Каждый символ
уникода представлен кодовой точкой, а способ кодирования кодовой точки зависит от
используемого формата преобразования уникода (UTF). Так, в формате UTF-16 для
кодирования большинства кодовых точек требуется одно 16-разрядное значение, а для
кодирования остальных кодовых точек — два 16-разрядных значения. Если для этой
цели требуются два 16-разрядных значения, то для их представления служат два зна­
чения типа char. Первое символьное значение называется старшим суррогатом, а вто­
рое — младшим суррогатом. В формате UTF-32 каждая кодовая точка кодируется с по­
мощью одного 32-разрядного значения. В структуре Char предоставляются все необхо­
димые средства для преобразования из формата UTF-16 в формат UTF-32 и обратно.
В отношении методов структуры Char необходимо также отметить следующее:
в используемых по умолчанию формах методов ToUpper() и ToLower() применя­
ются текущие настройки культурной среды (языки и региональные стандарты), чтобы
указать способ представления символов верхнего и нижнего регистра. На момент на­
писания этой книги рекомендовалось явно указывать текущие настройки культурной
среды, используя для этой цели параметр типа CultureInfo во второй форме обоих
упоминаемых методов. Класс CultureInfo относится к пространству имен System.
Globalization, а для указания текущей культурной среды следует передать свойство
CultureInfo.CurrentCulture соответствующему методу.
В структуре Char определены также следующие поля.
public const char MaxValue
public const char MinValue
Кроме того, в структуре Char реализуются следующие интерфейсы: IComparable,
IComparable<char>, IConvertible и IEquatable<char>.
Таблица 21.9. Методы, определенные в структуре Char
Метод Назначение
public int CompareTo(char
value)
Сравнивает символ в вызывающем объекте с сим­
волом value. Возвращает нуль, если сравнивае­
мые символы равны; отрицательное значение,
если вызывающий объект имеет меньшее зна­
чение; и, наконец, положительное значение, если
вызывающий объект имеет большее значение
public int CompareTo(object
value)
Сравнивает символ в вызывающем объекте с сим­
волом value. Возвращает нуль, если сравнивае­
мые символы равны; отрицательное значение,
если вызывающий объект имеет меньшее зна­
чение; и, наконец, положительное значение, если
вызывающий объект имеет большее значение
public static string
ConvertFromUtf32(int utf32)
Преобразует кодовую точку уникода, представ­
ленную параметром utf32 в формате UTF-32,
в символьную строку формата UTF-16 и возвра­
щает полученный результат
Продолжение табл. 21.9
Метод Назначение
pubic static int
ConvertToUtf32 (char
highSurrogate, char
lowSurrogate)
Преобразует старший и младший суррогаты,
представленные параметрами highSurrogate
и lowSurrogate в формате UTF-16, в кодовую
точку формата UTF-32 и возвращает полученный
результат
pubic static int
ConvertToUtf32(string s, int
index)
Преобразует пару суррогатов формата UTF-16,
доступных из символьной строки по индексу
s[index], в кодовую точку формата UTF-32 и
возвращает полученный результат
public bool Equals(char obj) Возвращает логическое значение true, если зна­
чение вызывающего объекта равно значению obj
public override bool
Equals(object obj)
Возвращает логическое значение true, если зна­
чение вызывающего объекта равно значению obj
public override int
GetHashCode()
Возвращает хеш-код для вызывающего объекта
public static double
GetNumericValue(char c)
Возвращает числовое значение символа с, если
он обозначает цифру. В противном случае возвра­
щает -1
public static double
GetNumericValue(string s, int
index)
Возвращает числовое значение символа, доступ­
ного из строки по индексу s[index], если он
обозначает цифру. В противном случае возвра­
щает -1
public TypeCode GetTypeCode() Возвращает значение из перечисления TypeCode
для структуры Char, т.е. TypeCode.Char
public static UnicodeCategory
GetUnicodeCategory(char c)
Возвращает значение из перечисления
UnicodeCategory для символа с. Перечисле­
ние UnicodeCategory определено в простран­
стве имен System.Globalization и распре­
деляет символы уникода по категориям
public static UnicodeCategory
GetUnicodeCategory(string s,
int index)
Возвращает значение из перечисления
UnicodeCategory для символа, доступного
из строки по индексу s[index]. Перечисление
UnicodeCategory определено в пространстве
имен System.Globalization и распределяет
символы уникода по категориям
public static bool
IsControl(char c)
Возвращает логическое значение true, если сим­
вол с является управляющим, иначе возвращает
логическое значение false
public static bool
IsControl(string s, int
index)
Возвращает логическое значение true, если сим­
вол, доступный из строки по индексу s[index],
является управляющим, иначе возвращает логи­
ческое значение false
public static bool
IsDigit(char c)
Возвращает логическое значение true, если
символ с обозначает цифру, а иначе возвращает
логическое значение false
Продолжение табл. 21.9
Метод Назначение
public static bool
IsDigit(string s, int index)
Возвращает логическое значение true, если сим­
вол, доступный из строки по индексу s[index],
обозначает цифру, а иначе возвращает логиче­
ское значение false
public static bool
IsHighSurrogate(char c)
Возвращает логическое значение true, если
символьное значение с является действительным
старшим суррогатом формата UTF-32, а иначе
возвращает логическое значение false
public static bool
IsHighSurrogate(string s, int
Index)
Возвращает логическое значение true, если сим­
вольное значение, доступное из строки по индек­
су s[index], является действительным старшим
суррогатом формата UTF-32, а иначе возвращает
логическое значение false
public static bool
IsLetter(char c)
Возвращает логическое значение true, если
символ с обозначает букву алфавита, а иначе воз­
вращает логическое значение false
public static bool
IsLetter(string s, int index)
Возвращает логическое значение true, если сим­
вол, доступный из строки по индексу s[index],
обозначает букву алфавита, а иначе возвращает
логическое значение false
public static bool
IsLetterOrDigit(char c)
Возвращает логическое значение true, если
символ с обозначает букву алфавита или цифру,
а иначе возвращает логическое значение false
public static bool
IsLetterOrDigit(string s, int
index)
Возвращает логическое значение true, если сим­
вол, доступный из строки по индексу s[index],
обозначает букву алфавита или цифру, а иначе
возвращает логическое значение false
public static bool
IsLower(char c)
Возвращает логическое значение true, если
символ с обозначает строчную букву алфавита,
а иначе возвращает логическое значение false
public static bool
IsLower(string s, int index)
Возвращает логическое значение true, если сим­
вол, доступный из строки по индексу s[index],
обозначает строчную букву алфавита, а иначе
возвращает логическое значение false
public static bool
IsLowSurrogate(char c)
Возвращает логическое значение true, если
символьное значение с является действительным
младшим суррогатом формата UTF-32, а иначе
возвращает логическое значение false
public static bool
IsLowSurrogate(string s, int
index)
Возвращает логическое значение true, если сим­
вольное значение, доступное из строки по индек­
су s[index], является действительным младшим
суррогатом формата UTF-32, а иначе возвращает
логическое значение false
public static bool
IsNumber(char c)
Возвращает логическое значение true, если
символ с обозначает число (десятичное или шест­
надцатеричное), а иначе возвращает логическое
значение false
Продолжение табл. 21.9
Метод Назначение
public static bool
IsNumber(string s, int index)
Возвращает логическое значение true, если сим­
вол, доступный из строки по индексу s[index], обо­
значает число (десятичное или шестнадцатеричное),
а иначе возвращает логическое значение false
public static bool
IsPunctuation(char c)
Возвращает логическое значение true, если
символ с обозначает знак препинания, а иначе
возвращает логическое значение false
public static bool
IsPunctuation(string s, int
index)
Возвращает логическое значение true, если сим­
вол, доступный из строки по индексу s[index],
обозначает знак препинания, а иначе возвра­
щает логическое значение false
public static bool
IsSeparator(char c)
Возвращает логическое значение true, если
символ с обозначает разделительный знак, а ина­
че возвращает логическое значение false
public static bool
IsSeparator(string s, int
index)
Возвращает логическое значение true, если сим­
вол, доступный из строки по индексу s[index],
обозначает разделительный знак, а иначе возвра­
щает логическое значение false
public static bool
IsSurrogate(char c)
Возвращает логическое значение true, если
символьное значение с является суррогатным
символом уникода, а иначе возвращает логиче­
ское значение false
public static bool
IsSurrogate(string s, int index)
Возвращает логическое значение true, если сим­
вольное значение, доступное из строки по индексу
s[index], является суррогатным символом унико­
да, а иначе возвращает логическое значение false
public static bool
IsSurrogatePair(char
highSurrogate, char
lowSurrogate)
Возвращает логическое значение true, если
символьные значения highSurrogate и
lowSurrogate образуют суррогатную пару
public static bool
IsSymbol(char c)
Возвращает логическое значение true, если
символ с обозначает символический знак, напри­
мер денежной единицы, а иначе возвращает ло­
гическое значение false
public static bool
IsSymbol(string s, int index)
Возвращает логическое значение true, если сим­
вол, доступный из строки по индексу s[index],
обозначает символический знак, например де­
нежной единицы, а иначе возвращает логическое
значение false
public static bool
IsUpper(char c)
Возвращает логическое значение true, если
символ с обозначает прописную букву алфавита,
а иначе возвращает логическое значение false
public static bool
IsUpper(string s, int index)
Возвращает логическое значение true, если сим­
вол, доступный из строки по индексу s[index],
обозначает прописную букву алфавита, а иначе
возвращает логическое значение false
Продолжение табл. 21.9
Метод Назначение
public static bool
IsWhiteSpace(char с)
Возвращает логическое значение true, если
символ с обозначает пробел, табуляцию или пу­
стую строку, а иначе возвращает логическое зна­
чение false
public static bool
IsWhiteSpace(string s, int
index)
Возвращает логическое значение true,
если символ, доступный из строки по индексу
s[index], обозначает пробел, табуляцию или
пустую строку, а иначе возвращает логическое
значение false
public static char
Parse(string s)
Возвращает эквивалент типа char символа
из строки s. Если строка s состоит из несколь­
ких символов, то генерируется исключение
FormatException
public static char
ToLower(char c)
Возвращает строчный эквивалент символа с,
если он обозначает прописную букву. В против­
ном случае значение символа с не изменяется
public static char
ToLowerfchar c, CultureInfo
culture)
Возвращает строчный эквивалент символа с,
если он обозначает прописную букву. В против­
ном случае значение символа с не изменяется.
Преобразование выполняется в соответствии с
информацией о культурной среде, указываемой
в параметре culture, где CultureInfo —
это класс, определенный в пространстве имен
System.Globalization
public static char
ToLowerInvariant(char c)
Возвращает строчный эквивалент символа с не­
зависимо от настроек культурной среды
public override string
ToString()
Возвращает строковое представление значения
вызывающего объекта типа Char
public static string
ToString(char c)
Возвращает строковое представление символь­
ного значения с
public string
ToString(IFormatProvider
provider)
Возвращает строковое представление значения
вызывающего объекта типа Char с учетом ин­
формации о культурной среде, указываемой в па­
раметре provider
public static char
ToUpper(char c)
Возвращает прописной эквивалент символа с,
если он обозначает строчную букву. В противном
случае значение символа с не изменяется
public static char
ToUpper(char c, CultureInfo
culture)
Возвращает прописной эквивалент символа с,
если он обозначает строчную букву. В противном
случае значение символа с не изменяется. Преоб­
разование выполняется в соответствии с инфор­
мацией о культурной среде, указываемой в пара­
метре culture, где CultureInfo — это класс,
определенный в пространстве имен System.
Globalization
Окончание табл. 21.9
Ниже приведен пример программы, в которой демонстрируется применение не­
скольких методов, определенных в структуре Char.
// Продемонстрировать применение нескольких методов,
// определенных в структуре Char.
using System;
using System.Globalization;
class CharDemo {
static void Main() {
string str = "Это простой тест. $23";
int i;
for(i=0; i < str.Length; i++) {
Console.Write(str[i] + " является");
if(Char.isDigit(str[i]))
Console.Write(" цифрой");
if(Char.IsLetter(str[i]))
Console.Write(" буквой");
if(Char.IsLower(str[i]))
Console.Write(" строчной");
if(Char.IsUpper(str[i]))
Console.Write(" прописной");
if(Char.IsSymbol(str [i]))
Console.Write(" символическим знаком");
if(Char.IsSeparator(str[i]))
Console.Write(" разделительным");
if(Char.IsWhiteSpace(str[i]))
Console.Write(" пробелом");
if(Char.IsPunctuation(str[i]))
Console.Write(" знаком препинания");
Console.WriteLine();
}
Метод Назначение
public static char
ToUpperInvariant(char c)
Возвращает прописной эквивалент символа с не­
зависимо от настроек культурной среды
public static bool
TryParse(string s, out char
result)
Предпринимает попытку преобразовать символ
из строки s в его эквивалентное значение типа
char. При успешной попытке это значение со­
храняется в параметре result и возвращается
логическое значение true. Если же строка s со­
стоит из нескольких символов, то возвращается
логическое значение false, в отличие от метода
Parse(), который генерирует исключение при
неудачном исходе преобразования
Console.WriteLine("Исходная строка: " + str);
// Преобразовать в прописные буквы.
string newstr = "";
for(i=0; i < str.Length; i++)
newstr += Char.ToUpper(str[i], CultureInfo.CurrentCulture);
Console.WriteLine("После преобразования: " + newstr);
}
}
Эта программа дает следующий результат.
Э является буквой прописной
т является буквой строчной
о является буквой строчной
является разделительным пробелом
п является буквой строчной
р является буквой строчной
о является буквой строчной
с является буквой строчной
т является буквой строчной
о является буквой строчной
й является буквой строчной
является разделительным пробелом
т является буквой строчной
е является буквой строчной
с является буквой строчной
т является буквой строчной
. является знаком препинания
является разделительным пробелом
$ является символическим знаком
2 является цифрой
3 является цифрой
Исходная строка: Это простой тест. $23
После преобразования: ЭТО ПРОСТОЙ ТЕСТ. $23
Структура Boolean
В структуре Boolean поддерживаются данные типа bool. Методы, определенные
в этой структуре, перечислены в табл. 21.10. Кроме того, в ней определены следующие
поля.
public static readonly string FalseString
public static readonly string TrueString
В этих полях логические значения true и false содержатся в удобочитае­
мой форме. Так, если вывести содержимое поля FalseString с помощью метода
WriteLine(), то на экране появится строка "False".
В структуре Boolean реализованы следующие интерфейсы: IComparable,
IComparable<bool>, IConvertible и IEquatable<bool>.
Таблица 21.10. Методы, определенные в структуре Boolean
Метод Назначение
public int CompareTo(bool
value).
Сравнивает логическое значение вызывающего объек­
та со значением параметра value. Возвращает нуль,
если сравниваемые значения равны; отрицательное
значение, если вызывающий объект имеет логическое
значение false, а параметр value — логическое зна­
чение true; и, наконец, положительное значение, если
вызывающий объект имеет логическое значение true,
а параметр value — логическое значение false
public int
CompareTo(object obj)
Сравнивает логическое значение вызывающего объек­
та со значением параметра obj. Возвращает нуль, если
сравниваемые значения равны; отрицательное значе­
ние, если вызывающий объект имеет логическое зна­
чение false, а параметр obj — логическое значение
true; и, наконец, положительное значение, если вызы­
вающий объект имеет логическое значение true, а па­
раметр obj — логическое значение false
public bool Equals(bool obj) Возвращает логическое значение true, если значение
вызывающего объекта равно значению параметра obj
public override bool
Equals(object obj)
Возвращает логическое значение true, если значение
вызывающего объекта равно значению параметра obj
public override int
GetHashCode()
Возвращает хеш-код для вызывающего объекта
public TypeCode
GetTypeCode()
Возвращает значение перечисления TypeCode для
структуры Boolean, т.е. TypeCode.Boolean
public static bool
Parse(string s)
Возвращает эквивалент типа bool символьной стро­
ки s. Если строка s не содержит ни поле Boolean.
TrueString, ни поле Boolean.FalseString, то
генерируется исключение FormatException, неза­
висимо от того, какими буквами набрано содержимое
строки: прописными или строчными
public override string
ToString()
Возвращает строковое представление значения вызы­
вающего объекта, которое должно быть либо значением
поля TrueString, либо значением поля FalseString
public string
ToString(IFormatProvider
provider)
Возвращает строковое представление значения вызы­
вающего объекта, которое должно быть либо значением
поля TrueString, либо значением поля FalseString.
При этом параметр provider игнорируется
public static bool
TryParse(string s, out
bool result)
Предпринимает попытку преобразовать символ из стро­
ки s в его эквивалентное значение типа bool. При
успешной попытке это значение сохраняется в пара­
метре result и возвращается логическое значение
true. Если же строка s не содержит ни поле Boolean.
TrueString, ни поле Boolean.FalseString, то воз­
вращается логическое значение false, независимо от
того, какими буквами набрано содержимое строки: про­
писными или строчными, в отличие от метода Parse(),
который генерирует исключение в аналогичной ситуации
Класс Array
Класс Array относится к числу наиболее часто используемых в пространстве имен
System. Он является базовым классом для всех массивов в С#. Следовательно, его ме­
тоды можно применять к массивам любого встроенного в C# типа или же к массивам
определяемого пользователем типа. Свойства, определенные в классе Array, перечис­
лены в табл. 21.11, а методы — в табл. 21.12.
В классе Array реализуются следующие интерфейсы: ICloneable, ICollection,
IEnumerable, IStructuralComparable, IStructuralEquatable, а также IList.
Все интерфейсы, кроме ICloneable, определены в пространстве имен System.
Collections, подробнее рассматриваемом в главе 25.
В ряде методов данного класса используется параметр типа IComparer или
IComparer<T>. Интерфейс IComparer находится в пространстве имен System.
Collections. В нем определяется метод Compare() для сравнения значений двух
объектов, как показано ниже.
int Compare(object х, object у)
Этот метод возвращает значение больше нуля, если х больше у; значение меньше
нудя, если х меньше у; и, наконец, нулевое значение, если оба значения равны.
Интерфейс IComparer<T> находится в пространстве имен System.Collections.
Generic. В нем определяется метод Compare(), общая форма которого приведена ниже.
int Compare(Т х, Т у)
Он действует таким же образом, как и его необобщенный аналог, возвращая значе­
ние больше нуля, если х больше у значение меньше нуля, если х меньше у, и, наконец,
нулевое значение, если оба значения равны. Преимущество интерфейса IComparer<T>
заключается в том, что он обеспечивает типовую безопасность. Ведь в этом случае тип
обрабатываемых данных указывается явным образом, а следовательно, никакого при­
ведения типов не требуется.
В последующих разделах демонстрируется ряд наиболее распространенных опера­
ций с массивами.
Таблица 21.11. Свойства, определенные в классе Array
Свойство Назначение
public bool IsFixedSize
{ get; }
Доступно только для чтения. Принимает логическое зна­
чение true, если массив имеет фиксированный размер,
и логическое значение false, если массив может изме­
нять его динамически
public bool IsReadOnly
{ get; }
Доступно только для чтения. Принимает логическое значение
true, если объект класса Array предназначен только для
чтения, а иначе — логическое значение false. Для масси­
вов это свойство всегда имеет логическое значение true
public bool
IsSynchronized { get; }
Доступно только для чтения. Принимает логическое зна­
чение true, если массив можно безопасно использовать
в многопоточной среде, а иначе — логическое значение
false. Для массивов это свойство всегда имеет логиче­
ское значение true
Таблица 21.12. Методы, определенные в классе Array
Окончание табл. 21.11
Свойство Назначение
public int Length {
get; }
Доступно только для чтения. Имеет тип int и содержит ко­
личество элементов в массиве
public long LongLength
{ get; }
Доступно только для чтения. Имеет тип long и содержит
количество элементов в массиве
public int Rank { get; } Доступно только для чтения. Содержит размерность массива
public object SyncRoot
{ get; }
Доступно только для чтения. Содержит объект, предназна­
ченный для синхронизации доступа к массиву
Метод Назначение
public static
ReadOnlyCollection<T>
AsReadOnly<T>(T[] array)
Возвращает доступную только для чтения коллек­
цию, которая включает в себя массив, определяе­
мый параметром array
public static int
BinarySearch(Array array,
object value)
Осуществляет поиск значения value в массиве
array. Возвращает индекс первого вхождения
искомого значения. Если оно не найдено, возвра­
щает отрицательное значение. Массив array дол­
жен быть отсортированным и одномерным
public static int
BinarySearch<T>(T[] array,
T value)
Осуществляет поиск значения value в массиве
array. Возвращает индекс первого вхождения
искомого значения. Если оно не найдено, возвра­
щает отрицательное значение. Массив array дол­
жен быть отсортированным и одномерным
public static int
BinarySearch(Array array,
object value, IComparer
comparer)
Осуществляет поиск значения value в масси­
ве, определяемом параметром array, исполь­
зуя способ сравнения, задаваемый параметром
comparer. Возвращает индекс первого вхожде­
ния искомого значения. Если оно не найдено, воз­
вращает отрицательное значение. Массив array
должен быть отсортированным и одномерным
public static int
BinarySearch<T>(T[] array,
T value, IComparer<T>
comparer)
Осуществляет поиск значения value в массиве
array, используя способ сравнения, задаваемый
параметром comparer. Возвращает индекс перво­
го вхождения искомого значения. Если оно не най­
дено, возвращает отрицательное значение. Массив
array должен быть отсортированным и одномерным
public static int
BinarySearch(Array array,
int index, int length,
object value)
Осуществляет поиск значения value в части мас­
сива array. Поиск начинается с индекса, зада­
ваемого параметром index, и охватывает число
элементов, определяемых параметром length.
Возвращает индекс первого вхождения искомого
значения. Если оно не найдено, возвращает отри­
цательное значение. Массив array должен быть
отсортированным и одномерным
Продолжение табл. 21.12
Метод Назначение
public static int
BinarySearch<T>(T[] array,
int index, int length, T
value)
Осуществляет поиск значения value в части мас­
сива array. Поиск начинается с индекса, зада­
ваемого параметром index, и охватывает число
элементов, определяемых параметром length.
Возвращает индекс первого вхождения искомого
значения. Если оно не найдено, возвращает отри­
цательное значение. Массив array должен быть
отсортированным и одномерным
public static int
BinarySearch(Array array,
int index, int length,
object value, IComparer
comparer)
Осуществляет поиск значения value в части мас­
сива array, используя способ сравнения, опреде­
ляемый параметром comparer. Поиск начинается
с индекса, задаваемого параметром index, и охва­
тывает число элементов, определяемых параме­
тром length. Возвращает индекс первого вхожде­
ния искомого значения. Если оно не найдено, воз­
вращает отрицательное значение. Массив array
должен быть отсортированным и одномерным
public static int
BinarySearch<T>(T [] array,
int index, int length,
T value, Icomparer<T>
comparer)
Осуществляет поиск значения value в части мас­
сива array, используя способ сравнения, опреде­
ляемый параметром comparer. Поиск начинается
с индекса, задаваемого параметром index, и охва­
тывает число элементов, определяемых параме­
тром length. Возвращает индекс первого вхожде­
ния искомого значения. Если оно не найдено, воз­
вращает отрицательное значение. Массив array
должен быть отсортированным и одномерным
public static void
Clear(Array array, int
index, int length)
Устанавливает заданные элементы массива array
равными нулю, пустому значению null или логи­
ческому значению false в зависимости от типа
элемента: значения, ссылочного или логического.
Подмножество элементов, подлежащих обнулению,
начинается с индекса, задаваемого параметром
index, и включает в себя число элементов, опре­
деляемых параметром length
public object Clone() Возвращает копию вызывающего массива. Эта ко­
пия ссылается на те же элементы, что и оригинал,
поэтому она называется “неполной". Таким обра­
зом, изменения, вносимые в элементы, влияют на
оба массива, поскольку и в том и в другом исполь­
зуются одни и те же элементы
public static void
ConstrainedCopy(Array
sourceArray, int sourceIndex,
Array destinationArray, int
destinationIndex, int length)
Копирует число элементов, задаваемых па­
раметром length, из исходного массива
sourceArray, начиная с элемента, указывае­
мого по индексу sourceIndex, в целевой мас­
сив destinationArray, начиная с элемента,
Продолжение табл. 21.12
Метод Назначение
указываемого по индексу destinationIndex. Если
оба массива имеют одинаковый ссылочный тип, то
метод ConstrainedCopy() создает “неполную ко­
пию”, в результате чего оба массива будут ссылаться
на одни и те же элементы. Если же во время копиро­
вания возникает ошибка, то содержимое целевого
массива destinationArray остается прежним
public static ТТо[]
ConvertAll<TInput,
ТТо>(TFrom[] array,
Converter<TOutput, TTo>
converter)
Преобразует массив array из типа TInput в тип
TOutput и возвращает получающийся в итоге
массив. Исходный массив остается прежним. Пре­
образование выполняется преобразователем, за­
даваемым параметром converter
public static void
Copy(Array sourceArray,
Array destinationArray, int
length)
Копирует число элементов, задаваемых параметром
length, из исходного массива sourceArray в це­
левой массив destinationArray, начиная с пер­
вого элемента массива. Если оба массива имеют
одинаковый ссылочный тип, то метод Сору() соз­
дает "неполную копию”, в результате чего оба мас­
сива будут ссылаться на одни и те же элементы. Если
же во время копирования возникает ошибка, то со­
держимое целевого массива destinationArray
оказывается неопределенным
public static void
Copy(Array sourceArray,
Array destinationArray, long
length)
Копирует число элементов, задаваемых параметром
length, из исходного массива sourceArray в це­
левой массив destinationArray, начиная с пер­
вого элемента массива. Если оба массива имеют
одинаковый ссылочный тип, то метод Сору() соз­
дает "неполную копию”, в результате чего оба мас­
сива будут ссылаться на одни и те же элементы. Если
же во время копирования возникает ошибка, то со­
держимое целевого массива destinationArray
оказывается неопределенным
public static void
Copy(Array sourceArray,
int sourceIndex, Array
destinationArray, int
destinationlndex, int
length)
Копирует число элементов, задаваемых параме­
тром length, из исходного массива sourceArray,
начиная с элемента, указываемого по индексу
sourceArray[sourceIndex], в целевой массив
destinationArray, начиная с элемента, указы­
ваемого по индексу destinationArray[destinationIndex].
Если оба массива имеют одина­
ковый ссылочный тип, то метод Сору() создает
“неполную копию", в результате чего оба массива
будут ссылаться на одни и те же элементы. Если же
во время копирования возникает ошибка, то со­
держимое целевого массива destinationArray
оказывается неопределенным
Продолжение табл. 21.12
Метод Назначение
public static void
Copy(Array sourceArray,
long sourceIndex, Array
destinationArray, long
destinationIndex, long
length)
Копирует число элементов, задаваемых параме­
тром length, из исходного массива sourceArray,
начиная с элемента, указываемого по индексу
sourceArray[sourceIndex], в целевой массив
destinationArray, начиная с элемента, указы­
ваемого по индексу destinationArray[destinationIndex].
Если оба массива имеют одина­
ковый ссылочный тип, то метод Сору() создает
"неполную копию”, в результате чего оба массива
будут ссылаться на одни и те же элементы. Если же
во время копирования возникает ошибка, то со­
держимое целевого массива destinationArray
оказывается неопределенным
public void CopyTo(Array
array, int index)
Копирует элементы вызывающего массива в це­
левой массив array, начиная с элемента, ука­
зываемого по индексу array[index]. Если же
во время копирования возникает ошибка, то со­
держимое целевого массива array оказывается
неопределенным
public void CopyTo(Array
array, long index)
Копирует элементы вызывающего массива в це­
левой массив array, начиная с элемента, ука­
зываемого по индексу array[index]. Если же
во время копирования возникает ошибка, то со­
держимое целевого массива array оказывается
неопределенным
public static Array
CreateInstance(Type
elementType, int length)
Возвращает ссылку на одномерный массив, кото­
рый содержит число элементов типа elementType,
определяемое параметром length
public static Array
Createlnstance(Type
elementType, int length1,
int length2)
Возвращает ссылку на двумерный массив разме­
ром length1×length2. Каждый элемент этого
массива имеет тип elementType
public static Array
Createlnstance(Type
elementType, int length1,
int length2, int length3)
 Возвращает ссылку на трехмерный массив разме­
ром length1×length2×length3. Каждый эле­
мент этого массива имеет тип elementType
public static Array
Createlnstance(Type
elementType, params int[]
lengths)
Возвращает ссылку на многомерный массив, раз­
мерность которого задается в массиве lengths.
Каждый элемент этого массива имеет тип
elementType
public static Array
Createlnstance(Type
elementType, params long[]
lengths)
Возвращает ссылку на многомерный массив, раз­
мерность которого задается в массиве lengths.
Каждый элемент этого массива имеет тип
elementType
Продолжение табл. 21.12
Метод Назначение
public static Array
Createlnstance(Type
elementType, int[]lengths,
int[] lowerBounds)
Возвращает ссылку на многомерный массив, раз­
мерность которого задается в массиве lengths.
Каждый элемент этого массива имеет тип
elementType. Начальный индекс каждого изме­
рения задается в массиве lowerBounds. Таким
образом, этот метод позволяет создавать массивы,
которые начинаются с некоторого индекса, отлич­
ного от нуля
public static bool
Exists<T>(T[] array,
Predicate<T> match)
Возвращает логическое значение true, если мас­
сив array содержит хотя бы один элемент, удо­
влетворяющий условию предиката, задаваемого
параметром match, а иначе возвращает логиче­
ское значение false
public static T Find<T>(T[]
array, Predicate<T> match)
Возвращает первый элемент массива array, удо­
влетворяющий условию предиката, задаваемого
параметром match, а иначе возвращает значение
типа default(Т)
public static T[]
FindAll<T>(T[] array,
Predicate<T> match)
Возвращает все элементы массива array, удо­
влетворяющие условию предиката, задаваемого
параметром match, а иначе возвращает массив
нулевой длины
public static int
FindIndex<T>(T[] array,
Predicate<T> match)
Возвращает индекс первого элемента массива
array, удовлетворяющего условию предиката, за­
даваемого параметром match, иначе возвращает
значение -1
public static int
FindIndex<T>(T[]array, int
startIndex, Predicate<T>
match)
Возвращает индекс первого элемента масси­
ва array, удовлетворяющего условию предика­
та, задаваемого параметром match. Поиск на­
чинается с элемента, указываемого по индексу
array[startIndex]. Если ни один из элемен­
тов, удовлетворяющих данному условию, не най­
ден, то возвращается значение -1
public static int
FindIndex<T>(T[] array,
int startlndex, int count,
Predicate<T> match)
Возвращает индекс первого элемента масси­
ва array, удовлетворяющего условию предика­
та, задаваемого параметром match. Поиск на­
чинается с элемента, указываемого по индексу
array[startIndex], и продолжается среди числа
элементов, определяемых параметром count. Если
ни один из элементов, удовлетворяющих данному
условию, не найден, то возвращается значение -1
public static T
FindLast<T>(T[] array,
Predicate<T> match)
Возвращает последний элемент массива array,
удовлетворяющий условию предиката, задаваемо­
го параметром match, иначе возвращает значе­
ние типа default(Т)
Продолжение табл. 21.12
Метод Назначение
public static int
FindLastIndex<T>(Т[] array,
Predicate<T> match)
Возвращает индекс последнего элемента массива
array, удовлетворяющего условию предиката, за­
даваемого параметром match, иначе возвращает
значение -1
public static int
FindLastIndex<T>(T[] array,
int startIndex, Predicate<T>
match)
Возвращает индекс последнего элемента массива
array, удовлетворяющего условию предиката, за­
даваемого параметром match. Поиск начинается
в обратном порядке с элемента, указываемого по
индексу array[startIndex], и оканчивается на
элементе array[0]. Если ни один из элементов,
удовлетворяющих данному условию, не найден, то
возвращается значение -1
public static int
FindLastIndex<T>(T[] array,
int startIndex, int count,
Predicate<T> match)
Возвращает индекс последнего элемента массива
array, удовлетворяющего условию предиката, за­
даваемого параметром v. Поиск начинается в об­
ратном порядке с элемента, указываемого по ин­
дексу array[start], и продолжается среди числа
элементов, определяемых параметром count. Если
ни один из элементов, удовлетворяющих данному
условию, не найден, то возвращается значение -1
public static void
ForEach<T>(T[]array,
Action<T> action)
Применяет метод, задаваемый параметром
action, к каждому элементу массива array
public IEnumerator
GetEnumerator()
Возвращает перечислительный объект для масси­
ва. Перечислители позволяют опрашивать массив
в цикле. Боле подробно перечислители описывают­
ся в главе 25
public override int
GetHashCode()
Возвращает хеш-код для вызывающего объекта
public int GetLength(int
dimension)
Возвращает длину заданного измерения массива.
Отсчет измерений начинается с нуля, поэтому для
получения длины первого измерения необходимо
передать данному методу значение 0 параметра
dimension, для получения длины второго измере­
ния — значение 1 и т.д.
public long GetLongLength(int
dimension)
Возвращает длину заданного измерения массива в
виде значения типа long. Отсчет измерений начи­
нается с нуля, поэтому для получения длины первого
измерения необходимо передать данному методу
значение 0 параметра dimension, для получения
длины второго измерения — значение 1 и т.д.
public int GetLowerBound(int
dimension)
Возвращает начальный индекс заданного измере­
ния массива, который обычно равен нулю. Пара­
метр dimension определяет отсчет измерений
Продолжение табл. 21.12
Метод Назначение
с нуля, поэтому для получения начального индекса
первого измерения необходимо передать данному
методу значение 0 параметра dimension, для по­
лучения начального индекса второго измерения —
значение 1 и т.д.
public int GetUpperBound(int
dimension)
Возвращает конечный индекс заданного измере­
ния массива. Параметр dimension определяет
отсчет измерений с нуля, поэтому для получения
конечного индекса первого измерения необходи­
мо передать данному методу значение 0 параме­
тра dimension, для получения конечного индекса
второго измерения — значение 1 и т.д.
public object GetValue(int
index)
Возвращает значение элемента из вызывающего
массива по индексу index. Массив должен быть
одномерным
public object GetValue(long
index)
Возвращает значение элемента из вызывающего
массива по индексу index. Массив должен быть
одномерным
public object GetValue(int
index1, int index2)
Возвращает значение элемента из вызывающего
массива по индексам [index1, index2]. Мас­
сив должен быть двумерным
public object GetValue(long
index1, long index2)
Возвращает значение элемента из вызывающего
массива по индексам [index1, index2]. Мас­
сив должен быть двумерным
public object GetValue(int
index1, int index2, int
index3)
Возвращает значение элемента из вызывающе­
го массива по индексам [index1, index2,
index3]. Массив должен быть трехмерным
public object GetValue(long
index1, long index2, long
idx3)
Возвращает значение элемента из вызывающе­
го массива по индексам [index1, index2,
index3]. Массив должен быть трехмерным
public object GetValue(int[]
indices)
Возвращает значение элемента из вызывающего
массива по указанным индексам. Число измере­
ний массива должно соответствовать числу эле­
ментов массива indices
public object
GetValue(long[] indices)
Возвращает значение элемента из вызывающего
массива по указанным индексам. Число измере­
ний массива должно соответствовать числу эле­
ментов массива indices
public static int
IndexOf(Array array, object
value)
Возвращает индекс первого элемента, имеющего
значение value в одномерном массиве array.
Если искомое значение не найдено, то возвращает
-1. (Если же массив имеет ненулевую нижнюю гра­
ницу, то неудачный исход поиска будет обозначаться
значением нижней границы, уменьшенным на 1.)
Продолжение табл. 21.12
Метод Назначение
public static int
IndexOf<T>(T[] array, T
value)
Возвращает индекс первого элемента, имеющего
значение value в одномерном массиве array.
Если искомое значение не найдено, то возвращает
-1
public static int
IndexOf(Array array, object
value, int startIndex)
Возвращает индекс первого элемента, имеющего
значение value в одномерном массиве array.
Поиск начинается с элемента, указываемого по ин­
дексу array[startIndex]. Метод возвращает
-1, если искомое значение не найдено. (Если мас­
сив имеет ненулевую нижнюю границу, то неудач­
ный исход поиска будет обозначаться значением
нижней границы, уменьшенным на 1.)
public static int
IndexOf<T>(T[] array, T
value, int startIndex)
Возвращает индекс первого элемента, имеющего
значение value в одномерном массиве array.
Поиск начинается с элемента, указываемого по
индексу array[startIndex]. Метод возвраща­
ет -1, если искомое значение не найдено
public static int
IndexOf(Array array, object
value, int startIndex, int
count)
Возвращает индекс первого элемента, имеющего
значение value в одномерном массиве array.
Поиск начинается с элемента, указываемого по
индексу array[startIndex], и продолжается
среди числа элементов, определяемых параме­
тром count. Метод возвращает -1, если искомое
значение не найдено в заданных пределах. (Если
же массив имеет ненулевую нижнюю границу, то
неудачный исход поиска будет обозначаться значе­
нием нижней границы, уменьшенным на 1.)
public static int
IndexOf<T>(T[] array, T
value, int startIndex, int
count)
Возвращает индекс первого элемента, имеющего
значение value в одномерном массиве array.
Поиск начинается с элемента, указываемого по
индексу array[startIndex], и продолжается
среди числа элементов, определяемых параме­
тром count. Метод возвращает -1, если искомое
значение не найдено в заданных пределах
public void Initialize() Инициализирует каждый элемент вызывающего
массива с помощью конструктора, используемо­
го по умолчанию для соответствующего элемента.
Этот метод можно использовать только для масси­
вов простых типов значений
public static int
LastlndexOf(Array array,
object value)
Возвращает индекс последнего элемента, имеюще­
го значение value в одномерном массиве array.
Если искомое значение не найдено, то возвращает
-1. (Если массив имеет ненулевую нижнюю грани­
цу, то неудачный исход поиска будет обозначаться
значением нижней границы, уменьшенным на 1.)
Продолжение табл. 21.12
Метод Назначение
public static int
LastIndexOf<T>(T[] array, T
value)
Возвращает индекс последнего элемента, имею­
щего значение value в одномерном массиве
array. Если искомое значение не найдено, то воз­
вращает -1
public static int
LastlndexOf(Array array,
object value, int startIndex)
Возвращает индекс последнего элемента, имеюще­
го значение value в одномерном массиве array.
Поиск начинается в обратном порядке с элемента,
указываемого по индексу array[startIndex],
и оканчивается на элементе а[0]. Метод возвра­
щает -1, если искомое значение не найдено. (Если
массив имеет ненулевую нижнюю границу, то неу­
дачный исход поиска будет обозначаться значени­
ем нижней границы, уменьшенным на 1.)
public static int
LastIndexOf<T>(T[] array, T
value, int startIndex)
Возвращает индекс последнего элемента, имеюще­
го значение value в одномерном массиве array.
Поиск начинается в обратном порядке с элемен­
та, указываемого по индексу а[startIndex], и
оканчивается на элементе а[0]. Метод возвра­
щает -1, если искомое значение не найдено
public static int
LastIndexOf(Array array,
object value, int startIndex,
int count)
Возвращает индекс последнего элемента, имеюще­
го значение value в одномерном массиве array.
Поиск начинается в обратном порядке с элемента,
указываемого по индексу array[startIndex],
и продолжается среди числа элементов, опреде­
ляемых параметром count. Метод возвращает -1,
если искомое значение не найдено в заданных пре­
делах. (Если массив имеет ненулевую нижнюю гра­
ницу, то неудачный исход поиска будет обозначаться
значением нижней границы, уменьшенным на 1.)
public static int
LastIndexOf<T>(T[]array, T
value, int startIndex, int
count)
Возвращает индекс последнего элемента, имеюще­
го значение value в одномерном массиве array.
Поиск начинается в обратном порядке с элемента,
указываемого по индексу array[startIndex], и
продолжается среди числа элементов, определяемых
параметром count. Метод возвращает -1, если ис­
комое значение не найдено в заданных пределах
public static void
Resize<T>(ref T[] array, int
newSize)
Задает длину newSize массива array
public static void
Reverse(Array array)
Меняет на обратный порядок следования элемен­
тов в массиве array
public static void
Reverse(Array array, int
index, int length)
Меняет на обратный порядок следования эле­
ментов массива array заданных в пределах,
начиная с элемента, указываемого по индексу
array[index], и включая число элементов,
определяемых параметром length
Продолжение табл. 21.12
Метод Назначение
public void SetValue(object
value, int index)
Устанавливает значение value элемента вызыва­
ющего массива по индексу index. Массив должен
быть одномерным
public void SetValue(object
value, long index)
Устанавливает значение value элемента вызыва­
ющего массива по индексу index. Массив должен
быть одномерным
public void SetValue(object
value, int index1, int index2)
Устанавливает значение value элемента вы­
зывающего массива по индексам [index1,
index2]. Массив должен быть двумерным
public void SetValue(object
value, long index1, long index2)
Устанавливает значение value элемента вы­
зывающего массива по индексам [index1,
index2]. Массив должен быть двумерным
public void SetValue(object
value, int index1, int
index2, int index3)
Устанавливает значение value элемента вызыва­
ющего массива по индексам [index1, index2,
index3]. Массив должен быть трехмерным
public void SetValue(object
value, long index1, long
index2, long index3)
Устанавливает значение value элемента вызыва­
ющего массива по индексам [index1, index2,
index3]. Массив должен быть трехмерным
public void SetValue(object
value, int[] indices)
Устанавливает значение value элемента вызы­
вающего массива по указанным индексам. Число
измерений массива должно соответствовать числу
элементов массива indices
public void SetValue(object
value, long[]indices)
Устанавливает значение value элемента вызы­
вающего массива по указанным индексам. Число
измерений массива должно соответствовать числу
элементов массива indices
public static void
Sort(Array array)
Сортирует массив array по нарастающей. Массив
должен быть одномерным
public static void
Sort<T>(T[]array)
Сортирует массив array по нарастающей. Массив
должен быть одномерным
public static void
Sort(Array array, IComparer
comparer)
Сортирует массив array по нарастающей, исполь­
зуя способ сравнения, задаваемый параметром
comparer. Массив должен быть одномерным
public static void
Sort<T> (T[] array,
Comparison<T> comparer)
Сортирует массив array по нарастающей, исполь­
зуя способ сравнения, задаваемый параметром
comparer. Массив должен быть одномерным
public static void
Sort<T> (T[] array,
IComparer<T> comparer)
Сортирует массив array по нарастающей, исполь­
зуя способ сравнения, задаваемый параметром
comparer. Массив должен быть одномерным
public static void
Sort(Array keys, Array
items)
Сортирует по нарастающей два заданных одномер­
ных массива. Массив keys содержит ключи сорти­
ровки, а массив items — значения, связанные с
этими ключами. Следовательно, оба массива долж­
ны содержать пары “ключ-значение”. После сорти­
ровки элементы обоих массивов располагаются по
порядку нарастания ключей
Продолжение табл. 21.12
Метод Назначение
public static void
Sort<TKey, TValue>(TKey[]
keys, TV[] items)
Сортирует по нарастающей два заданных одномер­
ных массива. Массив keys содержит ключи сорти­
ровки, а массив items — значения, связанные с
этими ключами. Следовательно, оба массива долж­
ны содержать пары “ключ-значение”. После сорти­
ровки элементы обоих массивов располагаются по
порядку возрастания ключей
public static void
Sort(Array keys, Array
items, Icomparer comparer)
Сортирует по нарастающей два заданных одномер­
ных массива, используя способ сравнения, задава­
емый параметром comparer. Массив keys содер­
жит ключи сортировки, а массив items — значения,
связанные с этими ключами. Следовательно, оба
массива должны содержать пары “ключ-значение”.
После сортировки элементы обоих массивов рас­
полагаются по порядку возрастания ключей
public static void
Sort<TKey, TValue>(TKey[]
keys, TValue[] items,
IComparer<TKey> comparer)
Сортирует по нарастающей два заданных одномер­
ных массива, используя способ сравнения, задава­
емый параметром comparer. Массив keys содер­
жит ключи сортировки, а массив items — значения,
связанные с этими ключами. Следовательно, оба
массива должны содержать пары “ключ-значение”.
После сортировки элементы обоих массивов рас­
полагаются по порядку возрастания ключей
public static void
Sort(Array array, int index,
int length)
Сортирует массив array по нарастающей в задан­
ных пределах, начиная с элемента, указываемого
по индексу array[index], и включая число эле­
ментов, определяемых параметром length. Мас­
сив должен быть одномерным
public static void
Sort<T>(T[] array, int
index, int length)
Сортирует массив array по нарастающей в задан­
ных пределах, начиная с элемента, указываемого
по индексу array[index], и включая число эле­
ментов, определяемых параметром length. Мас­
сив должен быть одномерным
public static void Sort(Array
array, int index, int length,
IComparer comparer)
Сортирует массив array по нарастающей в за­
данных пределах, начиная с элемента, указывае­
мого по индексу array[index], и включая число
элементов, определяемых параметром length, а
также используя способ сравнения, задаваемый
параметром v. Массив должен быть одномерным
public static void
Sort<T>(T[] array, int
index, int length,
Icomparer<T> comparer)
Сортирует массив array по нарастающей в задан­
ных пределах, начиная с элемента, указываемого по
индексу array[index], и включая число элемен­
тов, определяемых параметром length, а также
используя способ сравнения, задаваемый параме­
тром comparer. Массив должен быть одномерным
Продолжение табл. 21.12
Метод Назначение
public static void
Sort(Array keys, Array
Items, int index, int
length)
Сортирует по нарастающей два одномерных мас­
сива в заданных пределах, начиная с элемента,
указываемого по индексу index, и включая число
элементов, определяемых параметром length.
Массив keys содержит ключи сортировки, а мас­
сив items — значения, связанные с этими ключа­
ми. Следовательно, оба массива должны содержать
пары “ключ-значение”. После сортировки элемен­
ты обоих массивов располагаются в заданных пре­
делах по порядку возрастания ключей
public static void
Sort<TKey, TValue>(TKey[]
keys, TValue[] items, int
index, int length)
Сортирует по нарастающей два одномерных мас­
сива в заданных пределах, начиная с элемента,
указываемого по индексу index, и включая число
элементов, определяемых параметром length.
Массив keys содержит ключи сортировки, а мас­
сив items — значения, связанные с этими ключа­
ми. Следовательно, оба массива должны содержать
пары “ключ-значение”. После сортировки элемен­
ты обоих массивов располагаются в заданных пре­
делах по порядку возрастания ключей
public static void
Sort(Array keys, Array
items, int index, int
length, IComparer comparer)
Сортирует по нарастающей два одномерных мас­
сива в заданных пределах, начиная с элемента,
указываемого по индексу index, и включая число
элементов, определяемых параметром length, а
также используя способ сравнения, задаваемый
параметром comparer. Массив keys содержит
ключи сортировки, а массив items — значения,
связанные с этими ключами. Следовательно, эти
два массива должны содержать пары “ключ-
значение". После сортировки элементы обоих мас­
сивов располагаются в заданных пределах по по­
рядку возрастания ключей
public static void
Sort<TKey, TValue>(TKey[]
keys, TV items, int index,
int length, Icomparer<TKey>
comparer)
Сортирует по нарастающей два одномерных мас­
сива в заданных пределах, начиная с элемента,
указываемого по индексу index, и включая число
элементов, определяемых параметром length, а
также используя способ сравнения, задаваемый
параметром comparer. Массив keys содержит
ключи сортировки, а массив items — значения,
связанные с этими ключами. Следовательно, эти
два массива должны содержать пары.“ключ-
значение”. После сортировки элементы обоих мас­
сивов располагаются в заданных пределах по по­
рядку возрастания ключей
Метод Назначение
public static bool
TrueForAll<T>(Т[] array,
Predicate<T> match)
Возвращает логическое значение true, если все
элементы массива array удовлетворяют условию
предиката, задаваемого параметром match. Если
один или более элементов этого массива не удо­
влетворяют заданному условию, то возвращается
логическое значение false
Сортировка и поиск в массивах
Содержимое массива нередко приходится сортировать. Для этой цели в классе
Array предусмотрен обширный ряд сортирующих методов. Так, с помощью раз­
ных вариантов метода Sort() можно отсортировать массив полностью или в задан­
ных пределах либо отсортировать два массива, содержащих соответствующие пары
"ключ-значение". После сортировки в массиве можно осуществить эффективный по­
иск, используя разные варианты метода BinarySearch(). В качестве примера ниже
приведена программа, в которой демонстрируется применение методов Sort()
и BinarySearch() для сортировки и поиска в массиве значений типа int.
// Отсортировать массив и найти в нем значение.
using System;
class SortDemo {
static void Main() {
int[] nums = { 5, 4, 6, 3, 14, 9, 8, 17, 1, 24, -1, 0 };
// Отобразить исходный порядок следования.
Console.Write("Исходный порядок следования: ");
foreach(int i in nums)
Console.Write(i + " ");
Console.WriteLine();
// Отсортировать массив.
Array.Sort(nums);
// Отобразить порядок следования после сортировки.
Console.Write("Порядок следования после сортировки: ");
foreach(int i in nums)
Console.Write(i + " ");
Console.WriteLine();
// Найти значение 14.
int idx = Array.BinarySearch(nums, 14);
Console.WriteLine("Индекс элемента массива со значением 14: " +
idx);
}
}
Вот к какому результату приводит выполнение этой программы.
Исходный порядок следования: 5 4 6 3 14 9 8 17 1 24 -1 0
Порядок следования после сортировки: -1 0 1 3 4 5 6 8 9 14 17 24
Индекс элемента массива со значением 14: 9
Окончание табл. 21.12
В приведенном выше примере массив состоит из элементов типа int, который от­
носится к категории типов значений. Все методы, определенные в классе Array, авто­
матически доступны для обработки массивов всех встроенных в C# типов значений.
Но в отношении массивов ссылок на объекты это правило может и не соблюдаться.
Так, для сортировки массива ссылок на объекты в классе типа этих объектов должен
быть реализован интерфейс IComparable или IComparable<T>. Если же ни один из
этих интерфейсов не реализован в данном классе, то во время выполнения программы
может возникнуть исключительная ситуация в связи с попыткой отсортировать по­
добный массив или осуществить в нем поиск. Правда, реализовать оба интерфейса,
IComparable и IComparable<T>, совсем нетрудно.
В интерфейсе IComparable определяется один метод.
int CompareTo(object obj)
В этом методе значение вызывающего объекта сравнивается со значением объекта,
определяемого параметром obj. Если значение вызывающего объекта больше, чем
у объекта obj, то возвращается положительное значение; если оба значения равны —
нулевое значение, а если значение вызывающего объекта меньше, чем у объекта obj, —
отрицательное значение.
Интерфейс IComparable<T> является обобщенным вариантом интерфейса
IComparable. Поэтому в нем определен следующий обобщенный вариант метода
CompareTo().
int CompareTo(Т other)
Обобщенный вариант метода CompareTo() действует аналогично необобщенному
его варианту. В нем значение вызывающего объекта также сравнивается со значением
объекта, определяемого параметром other. Если значение вызывающего объекта боль­
ше, чем у объекта other, то возвращается положительное значение; если оба значения
равны — нулевое значение, а если значение вызывающего объекта меньше, чем у объек­
та other, — отрицательное значение. Преимущество интерфейса IComparable<T> за­
ключается в том, что он обеспечивает типовую безопасность, поскольку в этом случае
тип обрабатываемых данных указывается явным образом, а следовательно, никакого
приведения типа object сравниваемого объекта к нужному типу не требуется. В ка­
честве примера ниже приведена программа, в которой демонстрируются сортировка
и поиск в массиве объектов определяемого пользователем класса.
// Отсортировать массив объектов и осуществить в нем поиск.
using System;
class MyClass : IComparable<MyClass> {
public int i;
public MyClass(int x) { i = x; }
// Реализовать интерфейс IComparable<MyClass>.
public int CompareTo(MyClass v) {
return i - v.i;
}
public bool Equals(MyClass v) {
return i == v.i;
}
}
class SortDemo {
static void Main() {
MyClass[] nums = new MyClass[5];
nums[0] = new MyClass(5);
nums[1] = new MyClass(2);
nums[2] = new MyClass (3);
nums[3] = new MyClass (4);
nums[4] = new MyClass (1);
// Отобразить исходный порядок следования.
Console.Write("Исходный порядок следования: ");
foreach(MyClass о in nums)
Console.Write(о.i + " ");
Console.WriteLine();
// Отсортировать массив.
Array.Sort(nums);
// Отобразить порядок следования после сортировки.
Console.Write("Порядок следования после сортировки: ");
foreach(MyClass о in nums)
Console.Write(о.i + " ");
Console.WriteLine();
// Найти объект MyClass (2).
MyClass x = new MyClass(2);
int idx = Array.BinarySearch(nums, x);
Console.WriteLine("Индекс элемента массива с объектом MyClass(2): " +
idx);
}
}
При выполнении этой программы получается следующий результат.
Исходный порядок следования: 5 2 3 4 1
Порядок следования после сортировки: 1 2 3 4 5
Индекс элемента массива с объектом MyClass(2): 1
При сортировке или поиске в массиве строк может возникнуть потребность явно
указать способ сравнения символьных строк. Так, если массив будет сортироваться с
использованием одних настроек культурной среды, а поиск в нем — с помощью дру­
гих настроек, то во избежание ошибок, скорее всего, придется явно указать способ
сравнения. Аналогичная ситуация возникает и в том случае, если требуется отсорти­
ровать массив символьных строк при настройках культурной среды, отличающихся от
текущих. Для выхода из подобных ситуаций можно передать экземпляр объекта типа
StringComparer параметру типа IComparer, который поддерживается в целом ряде
перегружаемых вариантов методов Sort() и BinarySearch().
ПРИМЕЧАНИЕ
Более подробно особенности сравнения строк рассматриваются в главе 22.
Класс StringComparer объявляется в пространстве имен System и реализует,
среди прочего, интерфейсы IComparer и IComparer<T>. Поэтому экземпляр объек­
та типа StringComparer может быть передан в качестве аргумента параметру типа
IComparer. Кроме того, в классе StringComparer определен ряд доступных только
для чтения свойств, возвращающих экземпляр объекта типа StringComparer и под­
держивающих различные способы сравнения символьных строк. Все эти свойства пе­
речислены ниже.
Свойство Способ сравнения
public static StringComparer
CurrentCulture {get; }
С учетом регистра и культурной среды
public static StringComparer
CurrentCultureIgnoreCase {get; }
Без учета регистра, но с учетом культур­
ной среды
public static StringComparer
InvariantCulture {get; }
С учетом регистра и безотносительно
к культурной среде
public static StringComparer
InvariantCultureIgnoreCase {get; }
Без учета регистра и безотносительно
к культурной среде
public static StringComparer Ordinal
{get; }
Порядковое сравнение с учетом реги­
стра
public static StringComparer
OrdinalIgnoreCase {get; }
Порядковое сравнение без учета реги­
стра
Передавая явным образом экземпляр объекта типа StringComparer, можно со­
вершенно однозначно определить порядок сортировки или поиска в массиве. Напри­
мер, в приведенном фрагменте кода сортировка и поиск в массиве символьных строк
осуществляется с помощью свойства StringComparer.Ordinal.
string[] strs = { "xyz", "one" , "beta", "Alpha" };
// ...
Array.Sort(strs, StringComparer.Ordinal);
int idx = Array.BinarySearch(strs, "beta", StringComparer.Ordinal);
Обращение содержимого массива
Иногда оказывается полезно обратить содержимое массива и, в частности, отсорти­
ровать по убывающей массив, отсортированный по нарастающей. Для такого обраще­
ния массива достаточно вызвать метод Reverse(). С его помощью можно обратить
содержимое массива полностью иди частично. Этот процесс демонстрируется в при­
веденной ниже программе.
// Обратить содержимое массива.
using System;
class ReverseDemo {
static void Main() {
int[] nums = { 1, 2, 3, 4, 5 };
// Отобразить исходный порядок следования.
Console.Write("Исходный порядок следования: ");
foreach(int i in nums)
Console.Write(i + " ");
Console.WriteLine();
// Обратить весь массив.
Array.Reverse(nums);
// Отобразить обратный порядок следования.
Console.Write("Обратный порядок следования: ");
foreach(int i in nums)
Console.Write(i + " ");
Console.WriteLine();
// Обратить часть массива.
Array.Reverse(nums, 1, 3);
// Отобразить обратный порядок следования.
Console.Write("Частично обращенный порядок следования: ");
foreach(int i in nums)
Console.Write(i + " ");
Console.WriteLine();
}
}
Эта программа дает следующий результат.
Исходный порядок следования: 1 2 3 4 5
Обратный порядок следования: 5 4 3 2 1
Частично обращенный порядок следования: 5 2 3 4 1
Копирование массива
Полное или частичное копирование одного массива в другой — это еще одна весь­
ма распространенная операция с массивами. Для копирования содержимого массива
служит метод Сору(). В зависимости от его варианта копирование элементов исхо­
дного массива осуществляется в начало или в средину целевого массива. Применение
метода Сору() демонстрируется в приведенном ниже примере программы.
// Скопировать массив.
using System;
class CopyDemo {
static void Main() {
int[] source = { 1, 2, 3, 4, 5 };
int[] target = { 11, 12, 13, 14, 15 };
int[] source2 = { -1, -2, -3, -4, -5 };
// Отобразить исходный массив.
Console.Write("Исходный массив: ");
foreach(int i in source)
Console.Write(i + " ");
Console.WriteLine();
// Отобразить исходное содержимое целевого массива.
Console.Write("Исходное содержимое целевого массива: ");
foreach(int i in target)
Console.Write(i,+ " ");
Console.WriteLine();
// Скопировать весь массив.
Array.Copy(source, target, source.Length);
// Отобразить копию.
Console.Write("Целевой массив после копирования: ");
foreach(int i in target)
Console.Write(i + " ");
Console.WriteLine();
// Скопировать в средину целевого массива.
Array.Copy(source2, 2, target, 3, 2);
// Отобразить копию.
Console.Write("Целевой массив после частичного копирования: ");
foreach(int i in target)
Console.Write(i + " ");
Console.WriteLine();
}
}
Выполнение этой программы дает следующий результат.
Исходный массив: 1 2 3 4 5
Исходное содержимое целевого массива: 11 12 13 14 15
Целевой массив после копирования: 1 2 3 4 5
Целевой массив после частичного копирования: 1 2 3 -3 -4
Применение предиката
Предикат представляет собой делегат типа System.Predicate, возвращающий
логическое значение true иди false в зависимости от некоторого условия. Он объяв­
ляется следующим образом.
public delegate bool Predicate<T> (T obj)
Объект, проверяемый по заданному условию, передается в качестве параметра
obj. Если объект obj удовлетворяет заданному условию, то предикат должен возвра­
тить логическое значение true, в противном случае — логическое значение false.
Предикаты используются в ряде методов класса Array, включая: Exists(), Find(),
FindIndex() и FindAll().
В приведенном ниже примере программы демонстрируется применение предика­
та с целью определить, содержится ли в целочисленном массиве отрицательное зна­
чение. Если такое значение обнаруживается, то данная программа извлекает первое
отрицательное значение, найденное в массиве. Для этого в ней используются методы
Exists() и Find().
// Продемонстрировать применение предикатного делегата.
using System;
class PredDemo {
// Предикатный метод, возвращающий логическое значение true,
// если значение переменной v оказывается отрицательным.
static bool IsNeg(int v) {
if(v < 0) return true;
return false;
}
static void Main() {
int[] nums = { 1, 4, -1, 5, -9 };
Console.Write("Содержимое массива nums: ");
foreach(int i in nums)
Console.Write(i + " ");
Console.WriteLine();
// Сначала проверить, содержит ли массив nums отрицательное значение.
if(Array.Exists(nums, PredDemo.IsNeg)) {
Console.WriteLine("Массив nums содержит отрицательное значение.");
// Затем найти первое отрицательное значение в массиве.
int х = Array.Find(nums, PredDemo.IsNeg);
Console.WriteLine("Первое отрицательное значение: " + x);
}
else
Console.WriteLine("В массиве nums отсутствуют отрицательные значения.");
}
}
Эта программа дает следующий результат.
Содержимое массива nums: 1 4 -1 5 -9
Массив nums содержит отрицательное значение.
Первое отрицательное значение: -1
В данном примере программы в качестве предиката методам Exists() и Find()
передается метод IsNeg(). Обратите внимание на следующее объявление метода
IsNeg().
static bool IsNeg(int v) {
Методы Exists() и Find() автоматически и по порядку передают элементы мас­
сива переменной v. Следовательно, после каждого вызова метода IsNeg() переменная
v будет содержать следующий элемент массива.
Применение делегата Action
Делегат Action применяется в методе Array.ForEach() для выполнения заданного
действия над каждым элементом массива. Существуют разные формы делегата Action,
отличающиеся числом параметров типа. Ниже приведена одна из таких форм.
public delegate void Action<T> (T obj)
В этой форме объект, над которым должно выполняться действие, передается в ка­
честве параметра obj. Когда же эта форма делегата Action применяется в методе
Array.ForEach(), то каждый элемент массива передается по порядку объекту obj.
Следовательно, используя делегат Action и метод ForEach(), можно в одном опера­
торе выполнить заданную операцию над целым массивом.
В приведенном ниже примере программы демонстрируется применение делегата
Action и метода ForEach(). Сначала в ней создается массив объектов класса MyClass,
а затем используется метод Show() для отображения значений, извлекаемых из этого
массива. Далее эти значения становятся отрицательными с помощью метода Neg().
И наконец, метод Show() используется еще раз для отображения отрицательных зна­
чений. Все эти операции выполняются посредством вызовов метода ForEach().
// Продемонстрировать применение делегата Action.
using System;
class MyClass {
public int i;
public MyClass(int x) { i = x; }
}
class ActionDemo {
// Метод делегата Action, отображающий значение, которое ему передается.
static void Show(MyClass о) {
Console.Write(о.i + " ");
}
// Еще один метод делегата Action, делающий
// отрицательным значение, которое ему передается.
static void Neg(MyClass о) {
o.i = -o.i;
}
static void Main() {
MyClass[] nums = new MyClass[5];
nums[0] = new MyClass(5);
nums[1] = new MyClass(2);
nums[2] = new MyClass(3),
nums[3] = new MyClass(4);
nums[4] = new MyClass(1);
Console.Write("Содержимое массива nums: ");
// Выполнить действие для отображения значений.
Array.ForEach(nums, ActionDemo.Show);
Console.WriteLine();
// Выполнить действие для отрицания значений.
Array.ForEach(nums, ActionDemo.Neg);
Console.Write("Содержимое массива nums после отрицания: ");
// Выполнить действие для повторного отображения значений.
Array.ForEach(nums, ActionDemo.Show);
Console.WriteLine();
}
}
Ниже приведен результат выполнения этой программы.
Содержимое массива nums: 5 2 3 4 1
Содержимое массива nums после отрицания: -5 -2 -3 -4 -1
Класс BitConverter
В программировании нередко требуется преобразовать встроенный тип данных
в массив байтов. Допустим, что на некоторое устройство требуется отправить целое
значение, но сделать это нужно отдельными байтами, передаваемыми по очереди.
Часто возникает и обратная ситуация, когда данные получаются из устройства в виде
упорядоченной последовательности байтов, которые требуется преобразовать в один
из встроенных типов. Для подобных преобразований в среде .NET предусмотрен от­
дельный класс BitConverter.
Класс BitConverter является статическим. Он содержит методы, приведенные
в табл. 21.13. Кроме того, в нем определено следующее поле.
public static readonly bool IsLittleEndian
Это поле принимает логическое значение true, если в текущей среде сначала со­
храняется младший байт слова, а затем старший. Это так называемый формат с пря­
мым порядком байтов. А если в текущей среде сначала сохраняется старший байт
слова, а затем младший, то поле IsLittleEndian принимает логическое значение
false. Это так называемый формат с обратным порядком байтов. В компьютерах
с процессором Intel Pentium используется формат с прямым порядком байтов.
Таблица 21.13. Методы, определенные в классе BitConverter
Метод Назначение
public static long
DoubleToInt64Bits(double
value)
Преобразует значение value в целочисленное значение
типа long и возвращает результат
public static byte[]
GetBytes(bool value)
Преобразует значение value в однобайтовый массив и
возвращает результат
public static byte[]
GetBytes(char value)
Преобразует значение value в двухбайтовый массив и
возвращает результат
public static byte[]
GetBytes(double value)
Преобразует значение value в восьмибайтовый массив
и возвращает результат
public static byte[]
GetBytes(float value)
Преобразует значение value в четырехбайтовый массив
и возвращает результат
public static byte[]
GetBytes(int value)
Преобразует значение value в четырехбайтовый массив
и возвращает результат
public static byte[]
GetBytes(long value)
Преобразует значение value в восьмибайтовый массив
и возвращает результат
public static byte[]
GetBytes(short value)
Преобразует значение value в двухбайтовый массив и
возвращает результат
public static byte[]
GetBytes(uint value)
Преобразует значение value в четырехбайтовый массив
и возвращает результат
public static byte[]
GetBytes(ulong value)
Преобразует значение value в восьмибайтовый массив
и возвращает результат
Продолжение табл. 21.13
Метод Назначение
public static byte[]
GetBytes(ushort value)
Преобразует значение value в двухбайтовый массив
и возвращает результат
public static double
Int64BitsToDouble(long
value)
Преобразует значение value в значение типа double
и возвращает результат
public static bool
ToBoolean(byte[] value,
int startIndex)
Преобразует байт из элемента массива, указываемого по
индексу value[startIndex], в эквивалентное значе­
ние типа bool и возвращает результат. Ненулевое значе­
ние преобразуется в логическое значение true, а нуле­
вое — в логическое значение false
public static char
ToChar(byte[] value, int
index)
Преобразует два байта, начиная с элемента массива
value[index], в эквивалентное значение типа char
и возвращает результат
public static double
ToDouble(byte[] value,
int startIndex)
Преобразует восемь байтов, начиная с элемента массива
value[startIndex], в эквивалентное значение типа
double и возвращает результат
public static short
ToInt16(byte[] value,
int startIndex)
Преобразует два байта, начиная с элемента массива
value[startIndex], в эквивалентное значение типа
short и возвращает результат
public static int
ToInt32(byte[] value,
int startIndex)
Преобразует четыре байта, начиная с элемента массива
value[startIndex], в эквивалентное значение типа
int и возвращает результат
public static long
ToInt64(byte[] value,
int startIndex)
Преобразует восемь байтов, начиная с элемента массива
value[startIndex], в эквивалентное значение типа
long и возвращает результат
public static float
ToSingle(byte[] value,
int startIndex)
Преобразует четыре байта, начиная с элемента массива
value[startIndex], в эквивалентное значение типа
float и возвращает рiезультат
public static string
ToString(byte[] value)
Преобразует байты из массива value в символьную
строку. Строка содержит шестнадцатеричные значения,
связанные с этими байтами и разделенные дефисами
public static string
ToString(byte[] value,
int startIndex)
Преобразует байты из массива value в символьную
строку, начиная с элемента value[startIndex]. Стро­
ка содержит шестнадцатеричные значения, связанные
с этими байтами и разделенные дефисами
public static string
ToString(byte[] value,
int startIndex, int
length)
Преобразует байты из массива value в символьную
строку, начиная с элемента value[startIndex]
и включая число элементов, определяемых параметром
length. Строка содержит шестнадцатеричные значения,
связанные с этими байтами и разделенные дефисами
public static ushort
ToUInt16(byte[] value,
int startIndex)
Преобразует два байта, начиная с элемента массива
value[startIndex], в эквивалентное значение типа
ushort и возвращает результат
public static uint
ToUInt32(byte[] value,
int startIndex)
Преобразует четыре байта, начиная с элемента массива
value[startIndex], в эквивалентное значение типа
uint и возвращает результат
Метод Назначение
public static ulong
ToUInt64(byte[] value,
int startIndex)
Преобразует восемь байтов, начиная с элемента массива
value[startIndex], в эквивалентное значение типа
ulong и возвращает результат
Генерирование случайных чисел средствами класса Random
Для генерирования последовательного ряда случайных чисел служит класс Random.
Такие последовательности чисел оказываются полезными в самых разных ситуациях,
включая имитационное моделирование. Начало последовательности случайных чисел
определяется некоторым начальным числом, которое может задаваться автоматически
или указываться явным образом.
В классе Random определяются два конструктора.
public Random()
public Random(int seed)
Первый конструктор создает объект типа Random, использующий системное время
для определения начального числа. А во втором конструкторе используется начальное
значение seed, задаваемое явным образом.
Методы, определенные в классе Random, перечислены в табл. 21.14.
Таблица 21.14. Методы, определенные в классе Random
Окончание табл. 21.13
Метод Назначение
public virtual int Next() Возвращает следующее случайное целое число, ко­
торое будет находиться в пределах от 0 до Int32.
MaxValue-1 включительно
public virtual int Next(int
maxValue)
Возвращает следующее случайное целое число, кото­
рое будет находиться в пределах от 0 до maxValue-1
включительно
public virtual int Next(int
minValue, int maxValue)
Возвращает следующее случайное целое число, ко­
торое будет находиться в пределах от minValue до
maxValue-1 включительно
public virtual void
NextBytes(byte[] buffer)
Заполняет массив buffer последовательностью слу­
чайных целых чисел. Каждый байт в массиве будет
находиться в пределах от 0 до Byte.MaxValue-1
включительно
public virtual double
NextDouble()
Возвращает из последовательности следующее слу­
чайное число, которое представлено в форме с пла­
вающей точкой, больше или равно 0,0 и меньше 1,0
protected virtual double
Sample()
Возвращает из последовательности следующее слу­
чайное число, которое представлено в форме с пла­
вающей точкой, больше или равно 0,0 и меньше 1,0.
Для получения несимметричного или специального
распределения случайных чисел этот метод необхо­
димо переопределить в производном классе
Ниже приведена программа, в которой применение класса Random демонстрирует­
ся на примере создания компьютерного варианта пары игральных костей.
// Компьютерный вариант пары игральных костей.
using System;
class RandDice {
static void Main() {
Random ran = new Random();
Console.Write(ran.Next(1, 7) + " ");
Console.WriteLine(ran.Next(1, 7));
}
}
При выполнении этой программы три раза подряд могут быть подучены, напри­
мер, следующие результаты.
5 2
4 4
1 6
Сначала в этой программе создается объект класса Random. А затем в ней запраши­
ваются два случайных значения в пределах от 1 до 6.
Управление памятью и класс GC
В классе GC инкапсулируются средства "сборки мусора". Методы, определенные
в этом классе, перечислены в табл. 21.15.
Таблица 21.15. Методы, определенные в классе GC
Метод Назначение
public static
voidAddMemoryPressure(long
bytesAllocated)
Задает в качестве параметра bytesAllocated
количество байтов, распределенных в неуправ­
ляемой области памяти
public static void
CancelFullGCNotification()
Отменяет уведомление о “сборке мусора”
public static void Collect() Инициализирует процесс “сборки мусора”
public static void Collect(int
generation)
Инициализирует процесс “сборки мусора” в об­
ластях памяти с номерами поколений от 0 до
generation
public static void Collect(int
generation, GCCollectionMode
mode)
Инициализирует процесс "сборки мусора" в об­
ластях памяти с номерами поколений от 0 до
generation в режиме, определяемом пара­
метром mode
public static int
CollectionCount(int generation)
Возвращает количество операций “сборки му­
сора”, выполненных в области памяти с номе­
ром поколения generation
public static int
GetGeneration(object obj)
Возвращает номером поколения для области
памяти, доступной по ссылке obj
Продолжение табл. 21.15
Метод Назначение
public static int
GetGeneration(WeakReference wo)
Возвращает номер поколения для области па­
мяти, доступной по "слабой” ссылке, задавае­
мой параметром wo. Наличие "слабой” ссылки
не защищает объект от “сборки мусора”
public static long
GetTotalMemory(bool
forceFullCollection)
Возвращает общий объем памяти (в байтах),
выделенной на данный момент. Если параметр
forceFullCollection имеет логическое
значение true, то сначала выполняется “сбор­
ка мусора”
public static void
KeepAlive(object obj)
Создает ссылку на объект obj, защищая
его от “сборки мусора”. Действие этой ссыл­
ки оканчивается после выполнения метода
KeepAlive()
public static void Regist
erForFullGCNotification(in
t maxGenerationThreshold, int
largeObjectHeapThreshold)
Разрешает уведомление о "сборке мусора”. Зна­
чение параметра maxGenerationThreshold
обозначает количество объектов второго поко­
ления в обычной “куче”, которые будут иниции­
ровать уведомление. А значение параметра
largeObjectHeapThreshold обозначает
количество объектов в крупной “куче”, которые
будут инициировать уведомление. Оба значения
должны быть указаны в пределах от 1 до 99
public static void
RemoveMemoryPressure(long
bytesAllocated)
Задает в качестве параметра bytesAllocated
количество байтов, освобождаемых в неуправ­
ляемой области памяти
public static void
ReRegisterForFinalize(object
obj)
Вызывает деструктор для объекта obj.
Этот метод аннулирует действие метода
SuppressFinalize()
public static void
SuppressFinalize(object obj)
Препятствует вызову деструктора для объекта
obj
public static
GCNotificationStatus
WaitForFullGCApproach()
Ожидает уведомления о том, что должен про­
изойти полный цикл “сборки мусора”. Здесь
GCNotificationStatus — перечисление,
определенное в пространстве имен System
public static
GCNotificationStatus
WaitForFullGCApproach(int
milliseconds Timeout)
Ожидает уведомления о том, что должен
произойти полный цикл “сборки мусора”,
в течение времени, задаваемого пара­
метром millisecondsTimeout. Здесь
GCNotificationStatus — перечисление,
определенное в пространстве имен System
public static
GCNotificationStatus
WaitForFullGCComplete()
Ожидает уведомления о завершении
полного цикла “сборки мусора”. Здесь
GCNotificationStatus — перечисление,
определенное в пространстве имен System
Окончание табл. 21.15
Кроме того, в классе GC определяется следующее доступное только для чтения
свойство:
public static int MaxGeneration { get; }
Свойство MaxGeneration содержит максимальный номер поколения, доступный
для системы. Номер поколения обозначает возраст выделенной области памяти. Чем
старше выделенная область памяти, тем больше номер ее поколения. Номера поколе­
ний позволяют повысить эффективность работы системы "сборки мусора".
В большинстве приложений возможности класса GC не используются. Но в особых
случаях они оказываются весьма полезными. Допустим, что требуется организовать
принудительную "сборку мусора" с помощью метода Collect() в выбранный мо­
мент времени. Как правило, "сборка мусора" происходит в моменты, не указываемые
специально в программе. А поскольку для ее выполнения требуется некоторое время,
то желательно, чтобы она не происходила в тот момент, когда решается критичная по
времени задача. С другой стороны, "сборку мусора" и другие вспомогательные опе­
рации можно выполнить во время простоя программы. Имеется также возможность
регистрировать уведомления о приближении и завершении "сборки мусора".
Для проектов с неуправляемым кодом особое значение имеют два следующих мето­
да из класса GC:AddMemoryPressure() и RemoveMemoryPressure(). С их помощью
указывается большой объем неуправляемой памяти, выделяемой или освобождаемой
в программе. Особое значение этих методов состоит в том, что система управления
памятью не контролирует область неуправляемой памяти. Если программа выделя­
ет большой объем неуправляемой памяти, то это может сказаться на производитель­
ности, поскольку системе ничего неизвестно о таком сокращении объема свободно
доступной памяти. Если же большой объем неуправляемой памяти выделяется с по­
мощью метода AddMemoryPressure(), то система CLR уведомляется о сокращении
объема свободно доступной памяти. А если выделенная область памяти освобождает­
ся с помощью метода RemoveMemoryPressure(), то система CLR уведомляется о со­
ответствующем восстановлении объема свободно доступной памяти. Следует, однако,
иметь в виду, что метод RemoveMemoryPressure() необходимо вызывать только для
уведомления об освобождении области неуправляемой памяти, выделенной с помо­
щью метода AddMemoryPressure().
Метод Назначение
public static
GCNotificationStatus
WaitForFullGCComplete(int
milliseconds Timeout)
Ожидает уведомления о завершении полного
цикла "сборки мусора” в течение времени, зада­
ваемого параметром millisecondsTimeout.
Здесь GCNotif icationStatus — перечис­
ление, определенное в пространстве имен
System
public static void
WaitForPendingFinalizers()
Прекращает выполнение вызывающего потока
до тех пор, пока не будут выполнены все вы­
званные и незавершенные деструкторы
Класс object
В основу типа object в С# положен класс object. Члены класса Object под­
робно рассматривались в главе 11, но поскольку он играет главную роль в С#, то
его методы ради удобства повторно перечисляются в табл. 21.16. В классе object
определен конструктор
public Object()
который создает пустой объект.
Таблица 21.16. Методы, определенные в классе Object
Класс Tuple
В версии .NET Framework 4.0 внедрен удобный способ создания групп объектов
(так называемых кортежей). В основу этого способа положен статический класс Tuple,
в котором определяется несколько вариантов метода Create() для создания корте­
жей, а также различные обобщенные классы типа Tuple<...>, в которых инкапсу­
лируются кортежи. В качестве примера ниже приведено объявление варианта метода
Create(), возвращающего кортеж с тремя членами.
Метод Назначение
public virtual bool
Equals(object obj)
Возвращает логическое значение true, если вы­
зывающий объект оказывается таким же, как и
объект, определяемый параметром obj. В про­
тивном случае возвращается значение false
public static bool Equals(object
objA, object objВ)
Возвращает логическое значение true, если
объект objА оказывается таким же, как и объект
objВ. В противном случае возвращается значе­
ние false
protected Finalize() Выполняет завершающие действия перед процес­
сом "сборки мусора". В C# метод Finalize()
доступен через деструктор
public virtual int
GetHashCode()
Возвращает хеш-код, связанный с вызывающим
объектом
public Type GetType() Получает тип объекта во время выполнения про­
граммы
protected object
MemberwiseClone()
Создает "неполную" копию объекта. При этом ко­
пируются члены, но не объекты, на которые ссы­
лаются эти члены
public static bool
ReferenceEquals(object objA,
object objВ)
Возвращает логическое значение true, если
объекты objА и objВ ссылаются на один и тот
же объект. В противном случае возвращается ло­
гическое значение false
public virtual string
ToString()
Возвращает строку, описывающую объект
public static Tuple<T1, T2, T3>
Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3)
Следует заметить, что данный метод возвращает объект типа Tuple<T1, Т2, Т3>,
в котором инкапсулируются члены кортежа item1, item2 и item3. Вообще говоря,
кортежи оказываются полезными в том случае, если группу значений нужно интер­
претировать как единое целое. В частности, кортежи можно передавать методам, воз­
вращать из методов или же сохранять в коллекции либо в массиве.
Интерфейсы IComparable и IComparable<T>
Во многих классах приходится реализовывать интерфейс IComparable или
IComparable<T>, поскольку он позволяет сравнивать один объект с другим, используя
различные методы, определенные в среде .NET Framework. Интерфейсы IComparable
и IComparable<T> были представлены в главе 18, где они использовались в примерах
программ для сравнения двух объектов, определяемых параметрами обобщенного
типа. Кроме того, они упоминались при рассмотрении класса Array ранее в этой гла­
ве. Но поскольку эти интерфейсы имеют особое значение и применяются во многих
случаях, то ниже приводится их краткое описание.
Интерфейс IComparable реализуется чрезвычайно просто, потому что он состоит
всего лишь из одного метода.
int CompareTo(object obj)
В этом методе значение вызывающего объекта сравнивается со значением объекта,
определяемого параметром obj. Если значение вызывающего объекта больше, чем у
объекта obj, то возвращается положительное значение; если оба значения равны —
нулевое значение, а если значение вызывающего объекта меньше, чем у объекта obj, —
отрицательное значение.
Обобщенный вариант интерфейса IComparable объявляется следующим об­
разом.
public interface IComparable<T>
В данном варианте тип сравниваемых данных передается параметру Т в качестве ар­
гумента типа. В силу этого объявление метода CompareTo() претерпевает изменения
и выглядит так, как показано ниже.
int CompareTo(Т other)
В этом объявлении тип данных, которыми оперирует метод CompareTo(), может
быть указан явным образом. Следовательно, интерфейс IComparable<T> обеспечи­
вает типовую безопасность. Именно по этой причине он теперь считается более пред­
почтительным в программировании на С#, чем интерфейс IComparable.
Интерфейс IEquatable<T>
Интерфейс IEquatable<T> реализуется в тех классах, где требуется определить
порядок сравнения двух объектов на равенство их значений. В этом интерфейсе опре­
делен только один метод, Equals(), объявление которого приведено ниже.
bool Equals(T other)
Этот метод возвращает логическое значение true, если значение вызывающего
объекта оказывается равным значению другого объекта other, в противном случае —
логическое значение false.
Интерфейс IEquatable<T> реализуется в нескольких классах и структурах среды
.NET Framework, включая структуры числовых типов и класс String. Для реализа­
ции интерфейса IEquatable<T> обычно требуется также переопределять методы
Equals(Object) и GetHashCode(), определенные в классе Object.
Интерфейс IConvertible
Интерфейс IConvertible реализуется в структурах всех типов значений, String и
DateTime. В нем определяются различные преобразования типов. Реализовывать этот
интерфейс в создаваемых пользователем классах, как правило, не требуется.
Интерфейс ICloneable
Реализовав интерфейс ICloneable, можно создать все условия для копирования
объекта. В интерфейсе ICloneable определен только один метод, Clone(), объявле­
ние которого приведено ниже.
object Clone()
В этом методе создается копия вызывающего объекта, а конкретная его реализация
зависит от способа создания копии объекта. Вообще говоря, существуют две разно­
видности копий объектов: полная и неполная. Если создается полная копия, то ко­
пия совершенно не зависит от оригинала. Так, если в исходном объекте содержится
ссылка на другой объект О, то при его копировании создается также копия объекта О.
А при создании неполной копии осуществляется копирование одних только членов,
но не объектов, на которые эти члены ссылаются. Так, после создания неполной ко­
пии объекта, ссылающегося на другой объект О, копия и оригинал будут ссылаться на
один и тот же объект О, причем любые изменения в объекте О будут оказывать влия­
ние как на копию, так и на оригинал. Как правило, метод Clone() реализуется для
получения полной копии. А неполные копии могут быть созданы с помощью метода
MemberwiseClone(), определенного в классе Object.
Ниже приведен пример программы, в которой демонстрируется применение ин­
терфейса ICloneable. В ней создается класс Test, содержащий ссылку на объект клас­
са X. В самом классе Test используется метод Clone() для создания полной копии.
// Продемонстрировать применение интерфейса ICloneable.
using System;
class X {
public int a;
public X(int x) { a = x; }
}
class Test : ICloneable {
public X о;
public int b;
public Test(int x, int y) {
о = new X(x);
b = y;
}
public void Show(string name) {
Console.Write("Значения объекта " + name + ": ");
Console.WriteLine("о.a: {0}, b: {1}", o.a, b);
}
// Создать полную копию вызывающего объекта.
public object Clone() {
Test temp = new Test(o.a, b);
return temp;
}
}
class CloneDemo {
static void Main() {
Test ob1 = new Test(10, 20);
obi.Show("ob1");
Console.WriteLine("Сделать объект ob2 копией объекта оb1.");
Test ob2 = (Test) ob1.Clone();
ob2.Show("ob2");
Console.WriteLine("Изменить значение оb1.о.а на 99, " +
" а значение оb1.b - на 88.");
оb1.о.а = 99;
оb1.b = 88;
оb1.Show("оb1");
ob2.Show("оb2");
}
}
Ниже приведен результат выполнения этой программы.
Значения объекта оb1: о.а: 10, b: 20
Сделать объект оb2 копией объекта оb1.
Значения объекта оb2: о.а: 10, b: 20
Изменить значение оb1.о.а на 99, а значение оb1.b — на 88.
Значения объекта оb1: о.а: 99, b: 88
Значения объекта оb2: о.а: 10, b: 20
Как следует из результата выполнения приведенной выше программы, объект оb2
является копией объекта оb1, но это совершенно разные объекты. Изменения в одном
из них не оказывают никакого влияния на другой. Это достигается конструированием
нового объекта типа Test, который выделяет новый объект типа X для копирования.
При этом новому экземпляру объекта типа X присваивается такое же значение, как
и у объекта типа X в оригинале.
Для получения неполной копии достаточно вызвать метод MemberwiseClone(),
определяемый в классе Object из метода Clone(). В качестве упражнения попробуйте
заменить метод Clone() в предыдущем примере программы на следующий его вариант.
// Сделать неполную копию вызывающего объекта.
public object Clone() {
Test temp = (Test) MemberwiseClone();
return temp;
}
После этого изменения результат выполнения данной программы будет выглядеть
следующим образом.
Значения объекта оb1: о.а: 10, b: 20
Сделать объект оb2 копией объекта оb1.
Значения объекта оb2: о.а: 10, b: 20
Изменить значение оb1.о.а на 99, а значение оb1.b — на 88.
Значения объекта оb1: о.а: 99, b: 88
Значения объекта оb2: о.а: 99, b: 20
Как видите, обе переменные экземпляра о в объектах оb1 и оb2 ссылаются на один
и тот же объект типа X. Поэтому изменения в одном объекте оказывают влияние на
другой. Но в то же время поля b типа int в каждом из них разделены, поскольку типы
значений недоступны по ссылке.
Интерфейсы IFormatProvider и IFormattable
В интерфейсе IFormatProvider определен единственный метод GetFormat(), ко­
торый возвращает объект, определяющий форматирование данных в удобочитаемой
форме текстовой строки. Ниже приведена общая форма метода GetFormat():
object GetFormat(Type formatType)
где formatType — это объект, получаемый для форматирования.
Интерфейс IFormattable поддерживает форматирование выводимых результатов
в удобочитаемой форме. В нем определен следующий метод:
string ToString(string format, IFormatProvider formatProvider)
где format обозначает инструкции для форматирования, a formatProvider —
поставщик формата.
ПРИМЕЧАНИЕ
Подробнее о форматировании речь пойдет в главе 22.
Интерфейсы IObservable<T> и IObserver<T>
В версию .NET Framework 4.0 добавлены еще два интерфейса, поддерживающие
шаблон наблюдателя: IObservable<T> и IObserver<T>. В шаблоне наблюдателя
один класс (в роли наблюдаемого) предоставляет уведомления другому классу (в роли
наблюдателя). С этой целью объект наблюдаемого класса регистрирует объект наблю­
дающего класса. Для регистрации наблюдателя вызывается метод Subscribe(), ко­
торый определен в интерфейсе IObservable<T> и которому передается объект типа
IObserver<T>, принимающий уведомление. Для получения уведомлений можно
зарегистрировать несколько наблюдателей. А для отправки уведомлений всем за­
регистрированным наблюдателям применяются три метода, определенные в интер­
фейсе IObserver<T>. Так, метод OnNext() отправляет данные наблюдателю, метод
OnError() сообщает об ошибке, а метод OnCompleted() указывает на то, что наблю­
даемый объект прекратил отправку уведомлений.